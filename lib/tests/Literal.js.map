{"version":3,"sources":["../../src/tests/Literal.js"],"names":["exports","assert","throws","Literal","variable","cursor","Cursor","node","parse","equal","type","value","getIndex","getChar","isAtEnd","clone","getName","getType","getValue","getPatterns"],"mappings":"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","sourcesContent":["import Literal from \"../patterns/Literal.js\";\nimport Cursor from \"../Cursor.js\";\nimport assert from \"assert\";\n\nexports[\"Literal: Empty constructor.\"] = () => {\n  assert.throws(() => {\n    new Literal();\n  });\n};\n\nexports[\"Literal: Undefined literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\");\n  });\n};\n\nexports[\"Literal: Null literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\", null);\n  });\n};\n\nexports[\"Literal: Empty literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\", \"\");\n  });\n};\n\nexports[\"Literal: Match.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"var foo = 'Hello World';\");\n  const node = variable.parse(cursor);\n\n  assert.equal(node.type, \"variable\");\n  assert.equal(node.value, \"var\");\n  assert.equal(cursor.getIndex(), 3);\n  assert.equal(cursor.getChar(), \" \");\n};\n\nexports[\"Literal: Match at end.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"var\");\n  const node = variable.parse(cursor);\n\n  assert.equal(node.type, \"variable\");\n  assert.equal(node.value, \"var\");\n  assert.equal(cursor.getIndex(), 2);\n  assert.equal(cursor.getChar(), \"r\");\n  assert.equal(cursor.isAtEnd(), true);\n};\n\nexports[\"Literal: No match.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"vax\");\n\n  assert.throws(() => {\n    variable.parse(cursor);\n  });\n\n  assert.equal(cursor.getIndex(), 2);\n  assert.equal(cursor.getChar(), \"x\");\n};\n\nexports[\"Literal: Bad cursor.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n\n  assert.throws(() => {\n    variable.parse();\n  });\n\n};\n\nexports[\"Literal: Pattern methods.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const clone = variable.clone();\n\n  assert.equal(variable.getName(), clone.getName());\n  assert.equal(variable.getType(), clone.getType());\n  assert.equal(variable.getValue(), clone.getValue());\n  assert.equal(variable.getPatterns(), clone.getPatterns());\n};\n"],"file":"Literal.js"}