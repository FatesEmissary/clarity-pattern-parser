{"version":3,"sources":["../../src/tests/Literal.js"],"names":["exports","assert","throws","Literal","variable","cursor","Cursor","node","parse","equal","name","value","getIndex","getChar","isAtEnd","hasUnresolvedError","clone","children","length"],"mappings":";;AAAA;;AACA;;AACA;;;;AAEAA,OAAO,CAAC,6BAAD,CAAP,GAAyC,YAAM;AAC7CC,kBAAOC,MAAP,CAAc,YAAM;AAClB,QAAIC,gBAAJ;AACD,GAFD;AAGD,CAJD;;AAMAH,OAAO,CAAC,6BAAD,CAAP,GAAyC,YAAM;AAC7CC,kBAAOC,MAAP,CAAc,YAAM;AAClB,QAAIC,gBAAJ,CAAY,SAAZ;AACD,GAFD;AAGD,CAJD;;AAMAH,OAAO,CAAC,wBAAD,CAAP,GAAoC,YAAM;AACxCC,kBAAOC,MAAP,CAAc,YAAM;AAClB,QAAIC,gBAAJ,CAAY,SAAZ,EAAuB,IAAvB;AACD,GAFD;AAGD,CAJD;;AAMAH,OAAO,CAAC,yBAAD,CAAP,GAAqC,YAAM;AACzCC,kBAAOC,MAAP,CAAc,YAAM;AAClB,QAAIC,gBAAJ,CAAY,SAAZ,EAAuB,EAAvB;AACD,GAFD;AAGD,CAJD;;AAMAH,OAAO,CAAC,iBAAD,CAAP,GAA6B,YAAM;AACjC,MAAMI,QAAQ,GAAG,IAAID,gBAAJ,CAAY,UAAZ,EAAwB,KAAxB,CAAjB;AACA,MAAME,MAAM,GAAG,IAAIC,eAAJ,CAAW,0BAAX,CAAf;AACA,MAAMC,IAAI,GAAGH,QAAQ,CAACI,KAAT,CAAeH,MAAf,CAAb;;AAEAJ,kBAAOQ,KAAP,CAAaF,IAAI,CAACG,IAAlB,EAAwB,UAAxB;;AACAT,kBAAOQ,KAAP,CAAaF,IAAI,CAACI,KAAlB,EAAyB,KAAzB;;AACAV,kBAAOQ,KAAP,CAAaJ,MAAM,CAACO,QAAP,EAAb,EAAgC,CAAhC;;AACAX,kBAAOQ,KAAP,CAAaJ,MAAM,CAACQ,OAAP,EAAb,EAA+B,GAA/B;AACD,CATD;;AAWAb,OAAO,CAAC,wBAAD,CAAP,GAAoC,YAAM;AACxC,MAAMI,QAAQ,GAAG,IAAID,gBAAJ,CAAY,UAAZ,EAAwB,KAAxB,CAAjB;AACA,MAAME,MAAM,GAAG,IAAIC,eAAJ,CAAW,KAAX,CAAf;AACA,MAAMC,IAAI,GAAGH,QAAQ,CAACI,KAAT,CAAeH,MAAf,CAAb;;AAEAJ,kBAAOQ,KAAP,CAAaF,IAAI,CAACG,IAAlB,EAAwB,UAAxB;;AACAT,kBAAOQ,KAAP,CAAaF,IAAI,CAACI,KAAlB,EAAyB,KAAzB;;AACAV,kBAAOQ,KAAP,CAAaJ,MAAM,CAACO,QAAP,EAAb,EAAgC,CAAhC;;AACAX,kBAAOQ,KAAP,CAAaJ,MAAM,CAACQ,OAAP,EAAb,EAA+B,GAA/B;;AACAZ,kBAAOQ,KAAP,CAAaJ,MAAM,CAACS,OAAP,EAAb,EAA+B,IAA/B;AACD,CAVD;;AAYAd,OAAO,CAAC,oBAAD,CAAP,GAAgC,YAAM;AACpC,MAAMI,QAAQ,GAAG,IAAID,gBAAJ,CAAY,UAAZ,EAAwB,KAAxB,CAAjB;AACA,MAAME,MAAM,GAAG,IAAIC,eAAJ,CAAW,KAAX,CAAf;AAEAF,EAAAA,QAAQ,CAACI,KAAT,CAAeH,MAAf;;AAEAJ,kBAAOQ,KAAP,CAAaJ,MAAM,CAACU,kBAAP,EAAb,EAA0C,IAA1C;;AACAd,kBAAOQ,KAAP,CAAaJ,MAAM,CAACO,QAAP,EAAb,EAAgC,CAAhC;;AACAX,kBAAOQ,KAAP,CAAaJ,MAAM,CAACQ,OAAP,EAAb,EAA+B,GAA/B;AACD,CATD;;AAWAb,OAAO,CAAC,sBAAD,CAAP,GAAkC,YAAM;AACtC,MAAMI,QAAQ,GAAG,IAAID,gBAAJ,CAAY,UAAZ,EAAwB,KAAxB,CAAjB;;AAEAF,kBAAOC,MAAP,CAAc,YAAM;AAClBE,IAAAA,QAAQ,CAACI,KAAT;AACD,GAFD;AAGD,CAND;;AAQAR,OAAO,CAAC,2BAAD,CAAP,GAAuC,YAAM;AAC3C,MAAMI,QAAQ,GAAG,IAAID,gBAAJ,CAAY,UAAZ,EAAwB,KAAxB,CAAjB;AACA,MAAMa,KAAK,GAAGZ,QAAQ,CAACY,KAAT,EAAd;;AAEAf,kBAAOQ,KAAP,CAAaL,QAAQ,CAACM,IAAtB,EAA4BM,KAAK,CAACN,IAAlC;;AACAT,kBAAOQ,KAAP,CAAaL,QAAQ,CAACa,QAAT,CAAkBC,MAA/B,EAAuCF,KAAK,CAACC,QAAN,CAAeC,MAAtD;AACD,CAND","sourcesContent":["import Literal from \"../patterns/value/Literal.js\";\nimport Cursor from \"../Cursor.js\";\nimport assert from \"assert\";\n\nexports[\"Literal: Empty constructor.\"] = () => {\n  assert.throws(() => {\n    new Literal();\n  });\n};\n\nexports[\"Literal: Undefined literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\");\n  });\n};\n\nexports[\"Literal: Null literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\", null);\n  });\n};\n\nexports[\"Literal: Empty literal.\"] = () => {\n  assert.throws(() => {\n    new Literal(\"literal\", \"\");\n  });\n};\n\nexports[\"Literal: Match.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"var foo = 'Hello World';\");\n  const node = variable.parse(cursor);\n\n  assert.equal(node.name, \"variable\");\n  assert.equal(node.value, \"var\");\n  assert.equal(cursor.getIndex(), 2);\n  assert.equal(cursor.getChar(), \"r\");\n};\n\nexports[\"Literal: Match at end.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"var\");\n  const node = variable.parse(cursor);\n\n  assert.equal(node.name, \"variable\");\n  assert.equal(node.value, \"var\");\n  assert.equal(cursor.getIndex(), 2);\n  assert.equal(cursor.getChar(), \"r\");\n  assert.equal(cursor.isAtEnd(), true);\n};\n\nexports[\"Literal: No match.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const cursor = new Cursor(\"vax\");\n\n  variable.parse(cursor);\n\n  assert.equal(cursor.hasUnresolvedError(), true);\n  assert.equal(cursor.getIndex(), 0);\n  assert.equal(cursor.getChar(), \"v\");\n};\n\nexports[\"Literal: Bad cursor.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n\n  assert.throws(() => {\n    variable.parse();\n  });\n};\n\nexports[\"Literal: Pattern methods.\"] = () => {\n  const variable = new Literal(\"variable\", \"var\");\n  const clone = variable.clone();\n\n  assert.equal(variable.name, clone.name);\n  assert.equal(variable.children.length, clone.children.length);\n};\n"],"file":"Literal.js"}