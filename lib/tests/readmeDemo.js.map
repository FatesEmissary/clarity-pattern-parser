{"version":3,"sources":["../../src/tests/readmeDemo.js"],"names":["exports","forwardSlashes","Literal","newLine","returnCarriage","windowsNewLine","AndValue","lineEnd","OrValue","character","NotValue","comment","RepeatValue","lineEndingComment","string","cursor","Cursor","node","parse","assert","equal","name","value","expectedValue","type","startIndex","endIndex","JSON","stringify","AndComposite","children"],"mappings":"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","sourcesContent":["import {\n  Cursor,\n  Literal,\n  AndValue,\n  OrValue,\n  RepeatValue,\n  NotValue,\n  AndComposite\n} from \"../index.js\";\nimport assert from \"assert\";\n\nexports[\"readme.md: value\"] = () => {\n  const forwardSlashes = new Literal(\"forward-slashes\", \"//\");\n  const newLine = new Literal(\"new-line\", \"\\n\");\n  const returnCarriage = new Literal(\"return-carriage\", \"\\r\");\n  const windowsNewLine = new AndValue(\"windows-new-line\", [\n    returnCarriage,\n    newLine\n  ]);\n  const lineEnd = new OrValue(\"line-end\", [newLine, windowsNewLine]);\n  const character = new NotValue(\"character\", lineEnd);\n  const comment = new RepeatValue(\"comment\", character);\n\n  const lineEndingComment = new AndValue(\"line-ending-comment\", [\n    forwardSlashes,\n    comment,\n    lineEnd\n  ]);\n\n  const string = \"// This is a comment\\n\";\n  const cursor = new Cursor(string);\n  const node = lineEndingComment.parse(cursor);\n\n  assert.equal(node.name, \"line-ending-comment\"); // --> true\n  assert.equal(node.value, string); // --> true\n\n  const expectedValue = {\n    type: \"and-value\",\n    name: \"line-ending-comment\",\n    startIndex: 0,\n    endIndex: 20,\n    value: \"// This is a comment\\n\"\n  };\n\n  assert.equal(JSON.stringify(node), JSON.stringify(expectedValue)); // --> true\n};\n\nexports[\"readme.md: composite\"] = () => {\n  const forwardSlashes = new Literal(\"forward-slashes\", \"//\");\n  const newLine = new Literal(\"new-line\", \"\\n\");\n  const returnCarriage = new Literal(\"return-carriage\", \"\\r\");\n  const windowsNewLine = new AndValue(\"windows-new-line\", [\n    returnCarriage,\n    newLine\n  ]);\n  const lineEnd = new OrValue(\"line-end\", [newLine, windowsNewLine]);\n  const character = new NotValue(\"character\", lineEnd);\n  const comment = new RepeatValue(\"comment\", character);\n\n  const lineEndingComment = new AndComposite(\"line-ending-comment\", [\n    forwardSlashes,\n    comment,\n    lineEnd\n  ]);\n\n  const string = \"// This is a comment\\n\";\n  const cursor = new Cursor(string);\n  const node = lineEndingComment.parse(cursor);\n\n  assert.equal(node.name, \"line-ending-comment\");\n\n  assert.equal(node.children[0].name, \"forward-slashes\");\n  assert.equal(node.children[0].value, \"//\");\n\n  assert.equal(node.children[1].name, \"comment\");\n  assert.equal(node.children[1].value, \" This is a comment\");\n\n  assert.equal(node.children[2].name, \"line-end\");\n  assert.equal(node.children[2].value, \"\\n\");\n\n  const expectedValue = {\n    type: \"and-composite\",\n    name: \"line-ending-comment\",\n    startIndex: 0,\n    endIndex: 20,\n    children: [\n      {\n        type: \"literal\",\n        name: \"forward-slashes\",\n        startIndex: 0,\n        endIndex: 1,\n        value: \"//\"\n      },\n      {\n        type: \"repeat-value\",\n        name: \"comment\",\n        startIndex: 2,\n        endIndex: 19,\n        value: \" This is a comment\"\n      },\n      {\n        type: \"or-value\",\n        name: \"line-end\",\n        startIndex: 20,\n        endIndex: 20,\n        value: \"\\n\"\n      }\n    ]\n  };\n\n  assert.equal(JSON.stringify(node), JSON.stringify(expectedValue)); // --> true\n};\n"],"file":"readmeDemo.js"}