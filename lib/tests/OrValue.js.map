{"version":3,"sources":["../../src/tests/OrValue.js"],"names":["exports","assert","throws","OrValue","Literal","letter","AnyOfThese","number","alphaNumeric","letterCursor","Cursor","numberCursor","letterNode","parse","numberNode","equal","type","value","clone","getType","getValue","getPatterns","length","getName","longer","bang","orValue","cursor","node"],"mappings":"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","sourcesContent":["import OrValue from \"../patterns/OrValue.js\";\nimport AnyOfThese from \"../patterns/AnyOfThese.js\";\nimport Literal from \"../patterns/Literal.js\";\nimport Cursor from \"../Cursor.js\";\nimport assert from \"assert\";\n\nexports[\"OrValue: Empty constructor.\"] = () => {\n  assert.throws(() => {\n    new OrValue();\n  });\n};\n\nexports[\"OrValue: Undefined parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\");\n  });\n};\n\nexports[\"OrValue: Null patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", null);\n  });\n};\n\nexports[\"OrValue: Empty array parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", []);\n  });\n};\n\nexports[\"OrValue: One parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", [new Literal(\"some-value\")]);\n  });\n};\n\nexports[\"OrValue: Name and patterns.\"] = () => {\n  const letter = new AnyOfThese(\n    \"letter\",\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  );\n  const number = new AnyOfThese(\"number\", \"0987654321\");\n  const alphaNumeric = new OrValue(\"alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"a\");\n  const numberCursor = new Cursor(\"1\");\n\n  const letterNode = alphaNumeric.parse(letterCursor);\n  const numberNode = alphaNumeric.parse(numberCursor);\n\n  assert.equal(letterNode.type, \"alpha-numeric\");\n  assert.equal(letterNode.value, \"a\");\n\n  assert.equal(numberNode.type, \"alpha-numeric\");\n  assert.equal(numberNode.value, \"1\");\n};\n\nexports[\"OrValue: Optional Pattern as one of the patterns.\"] = () => {\n  const letter = new AnyOfThese(\n    \"letter\",\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  );\n  const number = new AnyOfThese(\"number\", \"0987654321\");\n  const alphaNumeric = new OrValue(\"alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"a\");\n  const numberCursor = new Cursor(\"1\");\n\n  const letterNode = alphaNumeric.parse(letterCursor);\n  const numberNode = alphaNumeric.parse(numberCursor);\n\n  assert.equal(letterNode.type, \"alpha-numeric\");\n  assert.equal(letterNode.value, \"a\");\n\n  assert.equal(numberNode.type, \"alpha-numeric\");\n  assert.equal(numberNode.value, \"1\");\n};\n\nexports[\"OrValue: Fail.\"] = () => {\n  const letter = new AnyOfThese(\"some-letter\", \"abc\");\n  const number = new AnyOfThese(\"some-number\", \"123\");\n  const alphaNumeric = new OrValue(\"some-alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"d\");\n  const numberCursor = new Cursor(\"4\");\n\n  assert.throws(() => {\n    const letterNode = alphaNumeric.parse(letterCursor);\n  });\n\n  assert.throws(() => {\n    const numberNode = alphaNumeric.parse(numberCursor);\n  });\n};\n\nexports[\"OrValue: Clone.\"] = () => {\n  const letter = new AnyOfThese(\"some-letter\", \"abc\");\n  const number = new AnyOfThese(\"some-number\", \"123\");\n  const alphaNumeric = new OrValue(\"some-alpha-numeric\", [letter, number]);\n\n  const clone = alphaNumeric.clone();\n\n  assert.equal(alphaNumeric.getType(), clone.getType());\n  assert.equal(alphaNumeric.getValue(), clone.getValue());\n  assert.equal(alphaNumeric.getPatterns().length, clone.getPatterns().length);\n  assert.equal(alphaNumeric.getName(), clone.getName());\n};\n\nexports[\"OrValue: Invalid patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"some-alpha-numeric\", [{}, null]);\n  });\n};\n\nexports[\"OrValue: Not enough patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"some-alpha-numeric\", [{}]);\n  });\n};\n\nexports[\"OrValue: Bad name.\"] = () => {\n  assert.throws(() => {\n    new OrValue({}, [new Literal(\"a\", \"a\"), new Literal(\"a\", \"a\")]);\n  });\n};\n\nexports[\"OrValue: Bad cursor.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"A\", [new Literal(\"a\", \"a\"), new Literal(\"a\", \"a\")]).parse();\n  });\n};\n\nexports[\"OrValue: Furthest Parse Error.\"] = () => {\n  const longer = new Literal(\"longer\", \"Longer\");\n  const bang = new Literal(\"bang\", \"Bang\");\n  const orValue = new OrValue(\"test\", [longer, bang]);\n  const cursor = new Cursor(\"Longed\");\n\n  assert.throws(() => {\n    orValue.parse(cursor);\n  });\n};\n\nexports[\"OrValue: Last pattern matches.\"] = () => {\n  const longer = new Literal(\"longer\", \"Longer\");\n  const bang = new Literal(\"bang\", \"Bang\");\n  const orValue = new OrValue(\"test\", [longer, bang]);\n  const cursor = new Cursor(\"Bang\");\n\n  const node = orValue.parse(cursor);\n\n  assert.equal(node.type, \"test\");\n  assert.equal(node.value, \"Bang\");\n};\n"],"file":"OrValue.js"}