{"version":3,"sources":["../../src/tests/OrValue.js"],"names":["exports","assert","throws","OrValue","Literal","letter","AnyOfThese","number","alphaNumeric","letterCursor","Cursor","numberCursor","letterNode","parse","numberNode","equal","type","value","clone","children","length","name","longer","bang","orValue","cursor","node"],"mappings":"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","sourcesContent":["import OrValue from \"../patterns/value/OrValue.js\";\nimport AnyOfThese from \"../patterns/value/AnyOfThese.js\";\nimport Literal from \"../patterns/value/Literal.js\";\nimport Cursor from \"../Cursor.js\";\nimport assert from \"assert\";\n\nexports[\"OrValue: Empty constructor.\"] = () => {\n  assert.throws(() => {\n    new OrValue();\n  });\n};\n\nexports[\"OrValue: Undefined parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\");\n  });\n};\n\nexports[\"OrValue: Null patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", null);\n  });\n};\n\nexports[\"OrValue: Empty array parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", []);\n  });\n};\n\nexports[\"OrValue: One parser.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"name\", [new Literal(\"some-value\")]);\n  });\n};\n\nexports[\"OrValue: Name and patterns.\"] = () => {\n  const letter = new AnyOfThese(\n    \"letter\",\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  );\n  const number = new AnyOfThese(\"number\", \"0987654321\");\n  const alphaNumeric = new OrValue(\"alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"a\");\n  const numberCursor = new Cursor(\"1\");\n\n  const letterNode = alphaNumeric.parse(letterCursor);\n  const numberNode = alphaNumeric.parse(numberCursor);\n\n  assert.equal(letterNode.type, \"alpha-numeric\");\n  assert.equal(letterNode.value, \"a\");\n\n  assert.equal(numberNode.type, \"alpha-numeric\");\n  assert.equal(numberNode.value, \"1\");\n};\n\nexports[\"OrValue: Optional Pattern as one of the patterns.\"] = () => {\n  const letter = new AnyOfThese(\n    \"letter\",\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  );\n  const number = new AnyOfThese(\"number\", \"0987654321\");\n  const alphaNumeric = new OrValue(\"alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"a\");\n  const numberCursor = new Cursor(\"1\");\n\n  const letterNode = alphaNumeric.parse(letterCursor);\n  const numberNode = alphaNumeric.parse(numberCursor);\n\n  assert.equal(letterNode.type, \"alpha-numeric\");\n  assert.equal(letterNode.value, \"a\");\n\n  assert.equal(numberNode.type, \"alpha-numeric\");\n  assert.equal(numberNode.value, \"1\");\n};\n\nexports[\"OrValue: Fail.\"] = () => {\n  const letter = new AnyOfThese(\"some-letter\", \"abc\");\n  const number = new AnyOfThese(\"some-number\", \"123\");\n  const alphaNumeric = new OrValue(\"some-alpha-numeric\", [letter, number]);\n\n  const letterCursor = new Cursor(\"d\");\n  const numberCursor = new Cursor(\"4\");\n\n  assert.throws(() => {\n    const letterNode = alphaNumeric.parse(letterCursor);\n  });\n\n  assert.throws(() => {\n    const numberNode = alphaNumeric.parse(numberCursor);\n  });\n};\n\nexports[\"OrValue: Clone.\"] = () => {\n  const letter = new AnyOfThese(\"some-letter\", \"abc\");\n  const number = new AnyOfThese(\"some-number\", \"123\");\n  const alphaNumeric = new OrValue(\"some-alpha-numeric\", [letter, number]);\n\n  const clone = alphaNumeric.clone();\n\n  assert.equal(alphaNumeric.children.length, clone.children.length);\n  assert.equal(alphaNumeric.name, clone.name);\n};\n\nexports[\"OrValue: Invalid patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"some-alpha-numeric\", [{}, null]);\n  });\n};\n\nexports[\"OrValue: Not enough patterns.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"some-alpha-numeric\", [{}]);\n  });\n};\n\nexports[\"OrValue: Bad name.\"] = () => {\n  assert.throws(() => {\n    new OrValue({}, [new Literal(\"a\", \"a\"), new Literal(\"a\", \"a\")]);\n  });\n};\n\nexports[\"OrValue: Bad cursor.\"] = () => {\n  assert.throws(() => {\n    new OrValue(\"A\", [new Literal(\"a\", \"a\"), new Literal(\"a\", \"a\")]).parse();\n  });\n};\n\nexports[\"OrValue: Furthest Parse Error.\"] = () => {\n  const longer = new Literal(\"longer\", \"Longer\");\n  const bang = new Literal(\"bang\", \"Bang\");\n  const orValue = new OrValue(\"test\", [longer, bang]);\n  const cursor = new Cursor(\"Longed\");\n\n  assert.throws(() => {\n    orValue.parse(cursor);\n  });\n};\n\nexports[\"OrValue: Last pattern matches.\"] = () => {\n  const longer = new Literal(\"longer\", \"Longer\");\n  const bang = new Literal(\"bang\", \"Bang\");\n  const orValue = new OrValue(\"test\", [longer, bang]);\n  const cursor = new Cursor(\"Bang\");\n\n  const node = orValue.parse(cursor);\n\n  assert.equal(node.type, \"test\");\n  assert.equal(node.value, \"Bang\");\n};\n"],"file":"OrValue.js"}