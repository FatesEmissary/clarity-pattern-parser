{"version":3,"sources":["../../src/tests/OrComposite.js"],"names":["exports","john","Literal","jane","cursor","Cursor","name","OrComposite","node","parse","assert","equal","value","getIndex","hasUnresolvedError","throws","OptionalValue","possibilities","getPossibilities","length","clone","children"],"mappings":"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","sourcesContent":["import OrComposite from \"../patterns/composite/OrComposite.js\";\nimport Literal from \"../patterns/value/Literal.js\";\nimport OptionalValue from \"../patterns/value/OptionalValue.js\";\nimport assert from \"assert\";\nimport { Cursor } from \"../index.js\";\n\nexports[\"OrComposite: Match.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n  const cursor = new Cursor(\"John\");\n  const name = new OrComposite(\"name\", [john, jane]);\n\n  const node = name.parse(cursor);\n\n  assert.equal(node.name, \"john\");\n  assert.equal(node.value, \"John\");\n};\n\nexports[\"OrComposite: No Match\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n  const cursor = new Cursor(\"Jeffrey\");\n  const name = new OrComposite(\"name\", [john, jane]);\n\n  const node = name.parse(cursor);\n\n  assert.equal(node, null);\n  assert.equal(cursor.getIndex(), 0);\n  assert.equal(cursor.hasUnresolvedError(), true);\n};\n\nexports[\"OrComposite: Supplied only one option.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n\n  assert.throws(() => {\n    new OrComposite(\"name\", [john]);\n  });\n};\n\nexports[\"OrComposite: Optional Children.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n\n  assert.throws(() => {\n    new OrComposite(\"name\", [new OptionalValue(john), new OptionalValue(jane)]);\n  });\n};\n\nexports[\"OrComposite: getPossibilities.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n  const name = new OrComposite(\"name\", [john, jane]);\n\n  const possibilities = name.getPossibilities();\n\n  assert.equal(possibilities.length, 2);\n  assert.equal(possibilities[0], \"John\");\n  assert.equal(possibilities[1], \"Jane\");\n};\n\nexports[\"OrComposite: parse with null cursor.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n  const cursor = new Cursor(\"John\");\n  const name = new OrComposite(\"name\", [john, jane]);\n\n  const node = name.parse(cursor);\n\n  assert.equal(node.name, \"john\");\n  assert.equal(node.value, \"John\");\n};\n\nexports[\"OrComposite: clone.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const jane = new Literal(\"jane\", \"Jane\");\n\n  const name = new OrComposite(\"name\", [john, jane]);\n  const clone = name.clone(\"name2\");\n\n  assert.equal(clone.name, \"name2\");\n  assert.equal(clone.children.length, 2);\n  assert.equal(clone.children[0].name, \"john\");\n  assert.equal(clone.children[1].name, \"jane\");\n};"],"file":"OrComposite.js"}