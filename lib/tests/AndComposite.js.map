{"version":3,"sources":["../../src/tests/AndComposite.js"],"names":["exports","john","Literal","doe","cursor","Cursor","name","AndComposite","node","parse","assert","equal","children","value","getIndex","hasUnresolvedError","parseError","message"],"mappings":";;AAAA;;AACA;;AACA;;AACA;;;;AAEAA,OAAO,CAAC,sBAAD,CAAP,GAAkC,YAAM;AACtC,MAAMC,IAAI,GAAG,IAAIC,gBAAJ,CAAY,MAAZ,EAAoB,MAApB,CAAb;AACA,MAAMC,GAAG,GAAG,IAAID,gBAAJ,CAAY,KAAZ,EAAmB,KAAnB,CAAZ;AACA,MAAME,MAAM,GAAG,IAAIC,aAAJ,CAAW,SAAX,CAAf;AACA,MAAMC,IAAI,GAAG,IAAIC,qBAAJ,CAAiB,MAAjB,EAAyB,CAACN,IAAD,EAAOE,GAAP,CAAzB,CAAb;AAEA,MAAMK,IAAI,GAAGF,IAAI,CAACG,KAAL,CAAWL,MAAX,CAAb;;AAEAM,kBAAOC,KAAP,CAAaH,IAAI,CAACF,IAAlB,EAAwB,MAAxB;;AACAI,kBAAOC,KAAP,CAAaH,IAAI,CAACI,QAAL,CAAc,CAAd,EAAiBN,IAA9B,EAAoC,MAApC;;AACAI,kBAAOC,KAAP,CAAaH,IAAI,CAACI,QAAL,CAAc,CAAd,EAAiBN,IAA9B,EAAoC,KAApC;;AACAI,kBAAOC,KAAP,CAAaH,IAAI,CAACI,QAAL,CAAc,CAAd,EAAiBC,KAA9B,EAAqC,MAArC;;AACAH,kBAAOC,KAAP,CAAaH,IAAI,CAACI,QAAL,CAAc,CAAd,EAAiBC,KAA9B,EAAqC,KAArC;AACD,CAbD;;AAeAb,OAAO,CAAC,wBAAD,CAAP,GAAoC,YAAM;AACtC,MAAMC,IAAI,GAAG,IAAIC,gBAAJ,CAAY,MAAZ,EAAoB,MAApB,CAAb;AACA,MAAMC,GAAG,GAAG,IAAID,gBAAJ,CAAY,KAAZ,EAAmB,KAAnB,CAAZ;AACA,MAAME,MAAM,GAAG,IAAIC,aAAJ,CAAW,WAAX,CAAf;AACA,MAAMC,IAAI,GAAG,IAAIC,qBAAJ,CAAiB,MAAjB,EAAyB,CAACN,IAAD,EAAOE,GAAP,CAAzB,CAAb;AAEA,MAAMK,IAAI,GAAGF,IAAI,CAACG,KAAL,CAAWL,MAAX,CAAb;;AAEAM,kBAAOC,KAAP,CAAaH,IAAb,EAAmB,IAAnB;;AACAE,kBAAOC,KAAP,CAAaP,MAAM,CAACU,QAAP,EAAb,EAAgC,CAAhC;;AACAJ,kBAAOC,KAAP,CAAaP,MAAM,CAACW,kBAAP,EAAb,EAA0C,IAA1C;;AACAL,kBAAOC,KAAP,CAAaP,MAAM,CAACY,UAAP,CAAkBC,OAA/B,EAAwC,6CAAxC;AACD,CAZH","sourcesContent":["import AndComposite from \"../patterns/composite/AndComposite.js\";\nimport Literal from \"../patterns/value/Literal.js\";\nimport assert from \"assert\";\nimport { Cursor } from \"../index.js\";\n\nexports[\"AndComposite: Match.\"] = () => {\n  const john = new Literal(\"john\", \"John\");\n  const doe = new Literal(\"doe\", \"Doe\");\n  const cursor = new Cursor(\"JohnDoe\");\n  const name = new AndComposite(\"name\", [john, doe]);\n\n  const node = name.parse(cursor);\n\n  assert.equal(node.name, \"name\");\n  assert.equal(node.children[0].name, \"john\");\n  assert.equal(node.children[1].name, \"doe\");\n  assert.equal(node.children[0].value, \"John\");\n  assert.equal(node.children[1].value, \"Doe\");\n};\n\nexports[\"AndComposite: No Match\"] = () => {\n    const john = new Literal(\"john\", \"John\");\n    const doe = new Literal(\"doe\", \"Doe\");\n    const cursor = new Cursor(\"JohnSmith\");\n    const name = new AndComposite(\"name\", [john, doe]);\n  \n    const node = name.parse(cursor);\n  \n    assert.equal(node, null);\n    assert.equal(cursor.getIndex(), 0);\n    assert.equal(cursor.hasUnresolvedError(), true);\n    assert.equal(cursor.parseError.message, \"ParseError: Expected 'Doe' but found 'Smi'.\");\n  };\n"],"file":"AndComposite.js"}