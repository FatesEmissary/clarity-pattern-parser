{"version":3,"sources":["../../src/tests/RecursivePattern.js"],"names":["exports","json","JSON","stringify","string","number","boolean","null","array","prop1","cursor","Cursor","cursor2","foo","object","literals","parse","assert","equal","name","toString","node","RecursivePattern","result","exec","clone","otherClone","tokens","getTokens","children","getNextTokens","possibilities","getPossibilities"],"mappings":"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","sourcesContent":["import assert from \"assert\";\nimport { RecursivePattern, Cursor } from \"../index.js\";\nimport literals from \"./javascriptPatterns/json.js\";\n\nexports[\"RecursivePattern: JSON\"] = () => {\n  const json = JSON.stringify({\n    string: \"This is a string.\",\n    number: 1,\n    boolean: true,\n    json: {\n      string: \"This is a nested string.\",\n    },\n    null: null,\n    array: [1, \"Blah\", { prop1: true }],\n  });\n\n  const cursor = new Cursor(json);\n  const cursor2 = new Cursor(JSON.stringify([{ foo: \"bar\" }]));\n\n  const object = literals.parse(cursor);\n  const array = literals.parse(cursor2);\n\n  assert.equal(object.name, \"object-literal\");\n  assert.equal(array.name, \"array-literal\");\n  assert.equal(object.toString(), json);\n};\n\nexports[\"RecursivePattern: No pattern\"] = () => {\n  const node = new RecursivePattern(\"nothing\");\n  const result = node.exec(\"Some string.\");\n\n  assert.equal(result, null);\n};\n\nexports[\"RecursivePattern: clone.\"] = () => {\n  const node = new RecursivePattern(\"nothing\");\n  const clone = node.clone();\n\n  assert.equal(node.name, clone.name);\n\n  const otherClone = node.clone(\"nothing2\");\n\n  assert.equal(otherClone.name, \"nothing2\");\n};\n\nexports[\"RecursivePattern: getNextTokens.\"] = () => {\n  let tokens = literals.getTokens();\n\n  tokens = literals.children[0].getNextTokens();\n\n  tokens = literals.children[4].getTokens();\n  tokens = literals.children[4].children[1].getNextTokens();\n  tokens = literals.children[4].children[2].getNextTokens();\n\n  tokens = literals.children[4].children[2].children[0].children[0].children[0].children[0].getTokens();\n  tokens = literals.children[4].children[2].children[0].children[0].getNextTokens();\n\n  tokens = literals.children[4].children[3].getNextTokens();\n};\n\nexports[\"RecursivePattern: getPossibilities.\"] = () => {\n  const possibilities = literals.getPossibilities();\n};\n"],"file":"RecursivePattern.js"}