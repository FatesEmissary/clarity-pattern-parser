{"version":3,"sources":["../src/CursorHistory.js"],"names":["CursorHistory","isRecording","furthestMatch","pattern","astNode","furthestError","patterns","astNodes","errors","push","endIndex","error","index","clear","length","stacks","reduce","acc","node","container","startIndex","cleanedStack","map","stack","x","currentNode","previousNode","unshift","left","Math","max","right","min","isOverlapping","getAllParseStacks"],"mappings":"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","sourcesContent":["export default class CursorHistory {\n  constructor() {\n    this.isRecording = false;\n\n    this.furthestMatch = {\n      pattern: null,\n      astNode: null,\n    };\n\n    this.furthestError = null;\n\n    this.patterns = [];\n    this.astNodes = [];\n    this.errors = [];\n  }\n\n  addMatch(pattern, astNode) {\n    if (this.isRecording) {\n      this.patterns.push(pattern);\n      this.astNodes.push(astNode);\n    }\n\n    if (\n      this.furthestMatch.astNode == null ||\n      astNode.endIndex >= this.furthestMatch.astNode.endIndex\n    ) {\n      this.furthestMatch.pattern = pattern;\n      this.furthestMatch.astNode = astNode;\n    }\n  }\n\n  addError(error) {\n    if (this.isRecording) {\n      this.errors.push(error);\n    }\n\n    if (this.furthestError == null || error.index >= this.furthestError.index) {\n      this.furthestError = error;\n    }\n  }\n\n  startRecording() {\n    this.isRecording = true;\n  }\n\n  stopRecording() {\n    this.isRecording = false;\n    this.clear();\n  }\n\n  clear() {\n    this.patterns.length = 0;\n    this.astNodes.length = 0;\n    this.errors.length = 0;\n  }\n\n  getFurthestError() {\n    return this.furthestError;\n  }\n\n  getFurthestMatch() {\n    return this.furthestMatch;\n  }\n\n  getLastMatch() {\n    if (this.isRecording) {\n      return {\n        pattern: this.patterns[this.patterns.length - 1] || null,\n        astNode: this.astNodes[this.astNodes.length - 1] || null,\n      };\n    } else {\n      return this.furthestMatch;\n    }\n  }\n\n  getLastError() {\n    return this.errors[this.errors.length - 1] || null;\n  }\n\n  getAllParseStacks() {\n    const stacks = this.astNodes.reduce((acc, node) => {\n      let container = acc[acc.length - 1];\n\n      if (node.startIndex === 0) {\n        container = [];\n        acc.push(container);\n      }\n\n      container.push(node);\n\n      return acc;\n    }, []);\n\n    // There are times when the matching will fail and hit again on the same node.\n    // This filters them out. \n    // We simply check to see if there is any overlap with the previous one,\n    // and if there is we don't add it. This is why we move backwards.\n    const cleanedStack = stacks.map((stack) => {\n      const cleanedStack = [];\n\n      for (let x = stack.length - 1; x >= 0; x--) {\n        const currentNode = stack[x];\n        const previousNode = stack[x + 1];\n\n        if (previousNode == null) {\n          cleanedStack.unshift(currentNode);\n        } else {\n          const left = Math.max(\n            currentNode.startIndex,\n            previousNode.startIndex\n          );\n          const right = Math.min(currentNode.endIndex, previousNode.endIndex);\n          const isOverlapping = left <= right;\n\n          if (!isOverlapping) {\n            cleanedStack.unshift(currentNode);\n          }\n        }\n      }\n      return cleanedStack;\n    });\n\n    return cleanedStack;\n  }\n\n  getLastParseStack() {\n    const stacks = this.getAllParseStacks();\n    return stacks[stacks.length - 1] || [];\n  }\n}\n"],"file":"CursorHistory.js"}