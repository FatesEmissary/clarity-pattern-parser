{"version":3,"sources":["../../src/patterns/And.js"],"names":["And","constructor","name","parsers","options","map","parser","clone","assertParsers","recoverFromBadOptions","forEach","parse","Error","length","isValue","isOptional","cursor","nodes","startingMark","mark","x","push","filteredNodes","filter","node","moveToMark","ParseError","every","ValueNode","value","join","startIndex","endIndex","CompositeNode","children"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEe,MAAMA,GAAN,CAAU;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgBC,OAAhB,EAAyB;AAClC,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAKD,OAAL,GAAeA,OAAO,CAACE,GAAR,CAAYC,MAAM,IAAIA,MAAM,CAACC,KAAP,EAAtB,CAAf;AAEA,SAAKC,aAAL;AACA,SAAKC,qBAAL;AACD;;AAEDD,EAAAA,aAAa,GAAG;AACd,SAAKL,OAAL,CAAaO,OAAb,CAAqBJ,MAAM,IAAI;AAC7B,UAAI,OAAOA,MAAM,CAACK,KAAd,KAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CACJ,uDADI,CAAN;AAGD;AACF,KAND;;AAQA,QAAI,KAAKT,OAAL,CAAaU,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAID,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF;;AAEDH,EAAAA,qBAAqB,GAAG;AACtB,QAAI,OAAO,KAAKL,OAAZ,KAAwB,QAAxB,IAAoC,KAAKA,OAAL,IAAgB,IAAxD,EAA8D;AAC5D,WAAKA,OAAL,GAAe,EAAf;AACA,WAAKA,OAAL,CAAaU,OAAb,GAAuB,KAAvB;AACA,WAAKV,OAAL,CAAaW,UAAb,GAA0B,KAA1B;AACD,KAJD,MAIO;AACL,UAAI,OAAO,KAAKX,OAAL,CAAaU,OAApB,KAAgC,SAApC,EAA+C;AAC7C,aAAKV,OAAL,CAAaU,OAAb,GAAuB,KAAvB;AACD;;AAED,UAAI,OAAO,KAAKV,OAAL,CAAaW,UAApB,KAAmC,SAAvC,EAAkD;AAChD,aAAKX,OAAL,CAAaW,UAAb,GAA0B,KAA1B;AACD;AACF;AACF;;AAEDJ,EAAAA,KAAK,CAACK,MAAD,EAAS;AACZ,UAAMC,KAAK,GAAG,EAAd;AACA,UAAMC,YAAY,GAAGF,MAAM,CAACG,IAAP,EAArB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,OAAL,CAAaU,MAAjC,EAAyCO,CAAC,EAA1C,EAA8C;AAC5CH,MAAAA,KAAK,CAACI,IAAN,CAAW,KAAKlB,OAAL,CAAaiB,CAAb,EAAgBT,KAAhB,CAAsBK,MAAtB,CAAX;AACD;;AAED,UAAMM,aAAa,GAAGL,KAAK,CAACM,MAAN,CAAaC,IAAI,IAAI;AACzC,aAAOA,IAAI,IAAI,IAAf;AACD,KAFqB,CAAtB;;AAIA,QAAIF,aAAa,CAACT,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,UAAI,KAAKT,OAAL,CAAaW,UAAjB,EAA6B;AAC3BC,QAAAA,MAAM,CAACS,UAAP,CAAkBP,YAAlB;AACA,eAAO,IAAP;AACD,OAHD,MAGO;AACL,cAAM,IAAIQ,mBAAJ,CAAgB,cAAa,KAAKxB,IAAK,WAAvC,CAAN;AACD;AACF;;AAED,QACE,KAAKE,OAAL,CAAaU,OAAb,IACAQ,aAAa,CAACK,KAAd,CAAoBH,IAAI,IAAIA,IAAI,YAAYI,kBAA5C,CAFF,EAGE;AACA,YAAMC,KAAK,GAAGP,aAAa,CAACjB,GAAd,CAAkBmB,IAAI,IAAIA,IAAI,CAACK,KAA/B,EAAsCC,IAAtC,CAA2C,EAA3C,CAAd;AACA,aAAO,IAAIF,kBAAJ,CACL,KAAK1B,IADA,EAEL2B,KAFK,EAGLP,aAAa,CAAC,CAAD,CAAb,CAAiBS,UAHZ,EAILT,aAAa,CAACA,aAAa,CAACT,MAAd,GAAuB,CAAxB,CAAb,CAAwCmB,QAJnC,CAAP;AAMD;;AAED,UAAMR,IAAI,GAAG,IAAIS,sBAAJ,CACX,KAAK/B,IADM,EAEXoB,aAAa,CAAC,CAAD,CAAb,CAAiBS,UAFN,EAGXT,aAAa,CAACA,aAAa,CAACT,MAAd,GAAuB,CAAxB,CAAb,CAAwCmB,QAH7B,CAAb;AAKAR,IAAAA,IAAI,CAACU,QAAL,GAAgBZ,aAAhB;AACA,WAAOE,IAAP;AACD;;AAEDjB,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIP,GAAJ,CAAQ,KAAKE,IAAb,EAAmB,KAAKC,OAAxB,EAAiC,KAAKC,OAAtC,CAAP;AACD;;AAvFsB","sourcesContent":["import CompositeNode from \"../ast/CompositeNode.js\";\nimport ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class And {\n  constructor(name, parsers, options) {\n    this.name = name;\n    this.options = options;\n    this.parsers = parsers.map(parser => parser.clone());\n\n    this.assertParsers();\n    this.recoverFromBadOptions();\n  }\n\n  assertParsers() {\n    this.parsers.forEach(parser => {\n      if (typeof parser.parse !== \"function\") {\n        throw new Error(\n          \"Invalid Argument: A Sequence can only accept parsers.\"\n        );\n      }\n    });\n\n    if (this.parsers.length < 2) {\n      throw new Error(\n        \"Invalid Arguments: A Sequence needs at least two options.\"\n      );\n    }\n  }\n\n  recoverFromBadOptions() {\n    if (typeof this.options !== \"object\" || this.options == null) {\n      this.options = {};\n      this.options.isValue = false;\n      this.options.isOptional = false;\n    } else {\n      if (typeof this.options.isValue !== \"boolean\") {\n        this.options.isValue = false;\n      }\n\n      if (typeof this.options.isOptional !== \"boolean\") {\n        this.options.isOptional = false;\n      }\n    }\n  }\n\n  parse(cursor) {\n    const nodes = [];\n    const startingMark = cursor.mark();\n\n    for (let x = 0; x < this.parsers.length; x++) {\n      nodes.push(this.parsers[x].parse(cursor));\n    }\n\n    const filteredNodes = nodes.filter(node => {\n      return node != null;\n    });\n\n    if (filteredNodes.length === 0) {\n      if (this.options.isOptional) {\n        cursor.moveToMark(startingMark);\n        return null;\n      } else {\n        throw new ParseError(`Expected a ${this.name} pattern.`);\n      }\n    }\n\n    if (\n      this.options.isValue &&\n      filteredNodes.every(node => node instanceof ValueNode)\n    ) {\n      const value = filteredNodes.map(node => node.value).join(\"\");\n      return new ValueNode(\n        this.name,\n        value,\n        filteredNodes[0].startIndex,\n        filteredNodes[filteredNodes.length - 1].endIndex\n      );\n    }\n\n    const node = new CompositeNode(\n      this.name,\n      filteredNodes[0].startIndex,\n      filteredNodes[filteredNodes.length - 1].endIndex\n    );\n    node.children = filteredNodes;\n    return node;\n  }\n\n  clone() {\n    return new And(this.name, this.parsers, this.options);\n  }\n}\n"],"file":"And.js"}