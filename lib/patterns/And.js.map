{"version":3,"sources":["../../src/patterns/And.js"],"names":["And","constructor","name","parsers","isValue","map","parser","clone","assertParsers","forEach","parse","Error","length","cursor","nodes","x","push","every","node","ValueNode","value","join","startIndex","endIndex","CompositeNode","children"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,GAAN,CAAU;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgBC,OAAO,GAAG,KAA1B,EAAiC;AAC1C,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKE,OAAL,GAAeA,OAAf;AACA,SAAKD,OAAL,GAAeA,OAAO,CAACE,GAAR,CAAYC,MAAM,IAAIA,MAAM,CAACC,KAAP,EAAtB,CAAf;AAEA,SAAKC,aAAL;AACD;;AAEDA,EAAAA,aAAa,GAAG;AACd,SAAKL,OAAL,CAAaM,OAAb,CAAqBH,MAAM,IAAI;AAC7B,UAAI,OAAOA,MAAM,CAACI,KAAd,KAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CACJ,uDADI,CAAN;AAGD;AACF,KAND;;AAQA,QAAI,KAAKR,OAAL,CAAaS,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAID,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,KAAK,CAACG,MAAD,EAAS;AACZ,UAAMC,KAAK,GAAG,EAAd;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKZ,OAAL,CAAaS,MAAjC,EAAyCG,CAAC,EAA1C,EAA8C;AAC5CD,MAAAA,KAAK,CAACE,IAAN,CAAW,KAAKb,OAAL,CAAaY,CAAb,EAAgBL,KAAhB,CAAsBG,MAAtB,CAAX;AACD,KALW,CAOZ;AACA;;;AACA,QAAI,KAAKT,OAAL,IAAgBU,KAAK,CAACG,KAAN,CAAYC,IAAI,IAAEA,IAAI,YAAYC,kBAAlC,CAApB,EAAiE;AAC/D,YAAMC,KAAK,GAAGN,KAAK,CAACT,GAAN,CAAUa,IAAI,IAAEA,IAAI,CAACE,KAArB,EAA4BC,IAA5B,CAAiC,EAAjC,CAAd;AACA,aAAO,IAAIF,kBAAJ,CAAc,KAAKjB,IAAnB,EAAyBkB,KAAzB,EAAgCN,KAAK,CAAC,CAAD,CAAL,CAASQ,UAAzC,EAAqDR,KAAK,CAACA,KAAK,CAACF,MAAN,GAAe,CAAhB,CAAL,CAAwBW,QAA7E,CAAP;AACD;;AAED,UAAML,IAAI,GAAG,IAAIM,sBAAJ,CACX,KAAKtB,IADM,EAEXY,KAAK,CAAC,CAAD,CAAL,CAASQ,UAFE,EAGXR,KAAK,CAACA,KAAK,CAACF,MAAN,GAAe,CAAhB,CAAL,CAAwBW,QAHb,CAAb;AAKAL,IAAAA,IAAI,CAACO,QAAL,GAAgBX,KAAhB;AACA,WAAOI,IAAP;AACD;;AAEDX,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIP,GAAJ,CAAQ,KAAKE,IAAb,EAAmB,KAAKC,OAAxB,CAAP;AACD;;AAlDsB","sourcesContent":["import CompositeNode from \"../ast/CompositeNode.js\";\nimport ValueNode from \"../ast/ValueNode.js\";\n\nexport default class And {\n  constructor(name, parsers, isValue = false) {\n    this.name = name;\n    this.isValue = isValue;\n    this.parsers = parsers.map(parser => parser.clone());\n\n    this.assertParsers();\n  }\n\n  assertParsers() {\n    this.parsers.forEach(parser => {\n      if (typeof parser.parse !== \"function\") {\n        throw new Error(\n          \"Invalid Argument: A Sequence can only accept parsers.\"\n        );\n      }\n    });\n\n    if (this.parsers.length < 2) {\n      throw new Error(\n        \"Invalid Arguments: A Sequence needs at least two options.\"\n      );\n    }\n  }\n\n  parse(cursor) {\n    const nodes = [];\n\n    for (let x = 0; x < this.parsers.length; x++) {\n      nodes.push(this.parsers[x].parse(cursor));\n    }\n\n    // If all nodes that match are ValueNodes than we reduce them into one Value node.\n    // This is a design decision that I'm still unsure about. However, I think it may be beneificial.\n    if (this.isValue && nodes.every(node=>node instanceof ValueNode)){\n      const value = nodes.map(node=>node.value).join(\"\");\n      return new ValueNode(this.name, value, nodes[0].startIndex, nodes[nodes.length - 1].endIndex);\n    }\n\n    const node = new CompositeNode(\n      this.name,\n      nodes[0].startIndex,\n      nodes[nodes.length - 1].endIndex\n    );\n    node.children = nodes;\n    return node;\n  }\n\n  clone() {\n    return new And(this.name, this.parsers);\n  }\n}\n"],"file":"And.js"}