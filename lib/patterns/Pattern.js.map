{"version":3,"sources":["../../src/patterns/Pattern.js"],"names":["Pattern","type","name","children","_type","_name","_children","_parent","isSequence","_assertName","Error","string","cursor","Cursor","node","parse","didSuccessfullyParse","exec","map","pattern","clone","Object","freeze","forEach","child","parent","siblings","index","findIndex","c","nextSibling","indexOf","tokens","getNextTokens","length","getTokens","concat","x","value","_cloneChildren","_assertChildren","_assignAsParent"],"mappings":"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","sourcesContent":["import Cursor from \"../Cursor.js\";\n\nexport default class Pattern {\n  constructor(type = null, name, children = []) {\n    this._type = type;\n    this._name = name;\n    this._children = [];\n    this._parent = null;\n    this.isSequence = false;\n\n    this._assertName();\n    this.children = children;\n  }\n\n  _assertName() {\n    if (typeof this.name !== \"string\") {\n      throw new Error(\n        \"Invalid Argument: Patterns needs to have a name that's a string.\"\n      );\n    }\n  }\n\n  parse() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  exec(string) {\n    const cursor = new Cursor(string);\n    const node = this.parse(cursor);\n\n    if (cursor.didSuccessfullyParse()) {\n      return node;\n    } else {\n      return null;\n    }\n  }\n\n  test(string) {\n    return this.exec(string) != null;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  set parent(value) {\n    if (value instanceof Pattern) {\n      this._parent = value;\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  set children(value) {\n    this._children = value;\n    this._cloneChildren();\n    this._assertChildren();\n    this._assignAsParent();\n  }\n\n  _assertChildren() {\n    // Empty, meant to be overridden by subclasses.\n  }\n\n  _cloneChildren() {\n    // We need to clone the patterns so nested patterns can be parsed.\n    this._children = this._children.map((pattern) => {\n      if (!(pattern instanceof Pattern)) {\n        throw new Error(\n          `The ${this.name} pattern has an invalid child pattern.`\n        );\n      }\n      return pattern.clone();\n    });\n\n    // We need to freeze the childen so they aren't modified.\n    Object.freeze(this._children);\n  }\n\n  _assignAsParent() {\n    this._children.forEach((child) => (child.parent = this));\n  }\n\n  clone() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  getPossibilities() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  getTokens() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  getNextTokens() {\n    if (this._parent != null) {\n      const siblings = this._parent.children;\n      const index = siblings.findIndex((c) => c === this);\n      const nextSibling = siblings[index + 1];\n\n      // I don't like this, so I think we need to rethink this.\n      if (this._parent.type.indexOf(\"repeat\") === 0) {\n        const tokens = this._parent.getNextTokens();\n        if (index === 0 && siblings.length > 1) {\n          return nextSibling.getTokens().concat(tokens);\n        } else if (index === 1) {\n          return siblings[0].getTokens().concat(tokens);\n        } else {\n          return this.getTokens().concat(tokens);\n        }\n      }\n\n      // Another thing I don't like.\n      if (\n        this._parent.type.indexOf(\"and\") === 0 &&\n        nextSibling != null &&\n        nextSibling.type.indexOf(\"optional\") === 0\n      ) {\n        let tokens = [];\n\n        for (let x = index + 1; x < siblings.length; x++) {\n          const child = siblings[x];\n\n          if (child.type.indexOf(\"optional\") === 0) {\n            tokens = tokens.concat(child.getTokens());\n          } else {\n            tokens = tokens.concat(child.getTokens());\n            break;\n          }\n\n          if (x === siblings.length - 1) {\n            tokens = tokens.concat(this._parent.getNextTokens());\n          }\n        }\n\n        return tokens;\n      }\n\n      // If you are an or you have already qualified.\n      if (this._parent.type.indexOf(\"or\") === 0) {\n        return this._parent.getNextTokens();\n      }\n\n      if (nextSibling != null) {\n        return nextSibling.getTokens();\n      } else {\n        return this._parent.getNextTokens();\n      }\n    }\n\n    return [];\n  }\n\n  getTokenValue() {\n    return null;\n  }\n}\n"],"file":"Pattern.js"}