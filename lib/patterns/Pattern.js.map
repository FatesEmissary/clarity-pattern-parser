{"version":3,"sources":["../../src/patterns/Pattern.js"],"names":["Pattern","type","name","children","_type","_name","_parent","_assertName","Error","string","cursor","Cursor","node","parse","didSuccessfullyParse","exec","_children","map","pattern","clone","Object","freeze","forEach","child","parent","value","_cloneChildren","_assertChildren","_assignAsParent"],"mappings":";;;;;;;AAAA;;;;;;;;;;IAEqBA,O;;;AACnB,qBAAqD;AAAA,QAAzCC,IAAyC,uEAAlC,IAAkC;AAAA,QAA5BC,IAA4B,uEAArB,IAAqB;AAAA,QAAfC,QAAe,uEAAJ,EAAI;;AAAA;;AACnD,SAAKC,KAAL,GAAaH,IAAb;AACA,SAAKI,KAAL,GAAaH,IAAb;AACA,SAAKI,OAAL,GAAe,IAAf;;AAEA,SAAKC,WAAL;;AACA,SAAKJ,QAAL,GAAgBA,QAAhB;AACD;;;;kCAEa;AACZ,UAAI,OAAO,KAAKD,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIM,KAAJ,CACJ,kEADI,CAAN;AAGD;AACF;;;4BAEO;AACN,YAAM,IAAIA,KAAJ,CAAU,wBAAV,CAAN;AACD;;;yBAEIC,M,EAAQ;AACX,UAAMC,MAAM,GAAG,IAAIC,eAAJ,CAAWF,MAAX,CAAf;AACA,UAAMG,IAAI,GAAG,KAAKC,KAAL,CAAWH,MAAX,CAAb;;AAEA,UAAIA,MAAM,CAACI,oBAAP,EAAJ,EAAmC;AACjC,eAAOF,IAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF;;;yBAEIH,M,EAAQ;AACX,aAAO,KAAKM,IAAL,CAAUN,MAAV,KAAqB,IAA5B;AACD;;;sCA+BiB,CAChB;AACD;;;qCAEgB;AAAA;;AACf;AACA,WAAKO,SAAL,GAAiB,KAAKA,SAAL,CAAeC,GAAf,CAAmB,UAAAC,OAAO,EAAI;AAC7C,YAAI,EAAEA,OAAO,YAAYlB,OAArB,CAAJ,EAAmC;AACjC,gBAAM,IAAIQ,KAAJ,eACG,KAAI,CAACN,IADR,4CAAN;AAGD;;AACD,eAAOgB,OAAO,CAACC,KAAR,EAAP;AACD,OAPgB,CAAjB,CAFe,CAWf;;AACAC,MAAAA,MAAM,CAACC,MAAP,CAAc,KAAKL,SAAnB;AACD;;;sCAEiB;AAAA;;AAChB,WAAKA,SAAL,CAAeM,OAAf,CAAuB,UAAAC,KAAK;AAAA,eAAKA,KAAK,CAACC,MAAN,GAAe,MAApB;AAAA,OAA5B;AACD;;;4BAEO;AACN,YAAM,IAAIhB,KAAJ,CAAU,wBAAV,CAAN;AACD;;;uCAEkB;AACjB,YAAM,IAAIA,KAAJ,CAAU,wBAAV,CAAN;AACD;;;wBA1DU;AACT,aAAO,KAAKH,KAAZ;AACD;;;wBAEU;AACT,aAAO,KAAKD,KAAZ;AACD;;;wBAEY;AACX,aAAO,KAAKE,OAAZ;AACD,K;sBAEUmB,K,EAAO;AAChB,UAAIA,KAAK,YAAYzB,OAArB,EAA8B;AAC5B,aAAKM,OAAL,GAAemB,KAAf;AACD;AACF;;;wBAEc;AACb,aAAO,KAAKT,SAAZ;AACD,K;sBAEYS,K,EAAO;AAClB,WAAKT,SAAL,GAAiBS,KAAjB;;AACA,WAAKC,cAAL;;AACA,WAAKC,eAAL;;AACA,WAAKC,eAAL;AACD","sourcesContent":["import Cursor from \"../Cursor.js\";\n\nexport default class Pattern {\n  constructor(type = null, name = null, children = []) {\n    this._type = type;\n    this._name = name;\n    this._parent = null;\n\n    this._assertName();\n    this.children = children;\n  }\n\n  _assertName() {\n    if (typeof this.name !== \"string\") {\n      throw new Error(\n        \"Invalid Argument: Patterns needs to have a name that's a string.\"\n      );\n    }\n  }\n\n  parse() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  exec(string) {\n    const cursor = new Cursor(string);\n    const node = this.parse(cursor);\n\n    if (cursor.didSuccessfullyParse()) {\n      return node;\n    } else {\n      return null;\n    }\n  }\n\n  test(string) {\n    return this.exec(string) != null;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  get type() {\n    return this._type;\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  set parent(value) {\n    if (value instanceof Pattern) {\n      this._parent = value;\n    }\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  set children(value) {\n    this._children = value;\n    this._cloneChildren();\n    this._assertChildren();\n    this._assignAsParent();\n  }\n\n  _assertChildren() {\n    // Empty, meant to be overridden by subclasses.\n  }\n\n  _cloneChildren() {\n    // We need to clone the patterns so nested patterns can be parsed.\n    this._children = this._children.map(pattern => {\n      if (!(pattern instanceof Pattern)) {\n        throw new Error(\n          `The ${this.name} pattern has an invalid child pattern.`\n        );\n      }\n      return pattern.clone();\n    });\n\n    // We need to freeze the childen so they aren't modified.\n    Object.freeze(this._children);\n  }\n\n  _assignAsParent() {\n    this._children.forEach(child => (child.parent = this));\n  }\n\n  clone() {\n    throw new Error(\"Method Not Implemented\");\n  }\n\n  getPossibilities() {\n    throw new Error(\"Method Not Implemented\");\n  }\n}\n"],"file":"Pattern.js"}