{"version":3,"sources":["../../src/patterns/Or.js"],"names":["Or","constructor","parsers","map","parser","clone","cursor","index","mark","errors","assertParsers","forEach","parse","Error","length","reset","tryParser","error","push","moveToMark","throwError","furthestError","reduce"],"mappings":";;;;;;;AAAe,MAAMA,EAAN,CAAS;AACtBC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACnB,SAAKA,OAAL,GAAeA,OAAO,CAACC,GAAR,CAAYC,MAAM,IAAIA,MAAM,CAACC,KAAP,EAAtB,CAAf;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AAEA,SAAKC,aAAL;AACD;;AAEDA,EAAAA,aAAa,GAAG;AACd,SAAKR,OAAL,CAAaS,OAAb,CAAqBP,MAAM,IAAI;AAC7B,UAAI,OAAOA,MAAM,CAACQ,KAAd,KAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF,KAND;;AAQA,QAAI,KAAKX,OAAL,CAAaY,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAID,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,KAAK,CAACN,MAAD,EAAS;AACZ,SAAKS,KAAL,CAAWT,MAAX;AACA,WAAO,KAAKU,SAAL,EAAP;AACD;;AAEDD,EAAAA,KAAK,CAACT,MAAD,EAAS;AACZ,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,KAAKF,MAAL,CAAYE,IAAZ,EAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACD;;AAEDO,EAAAA,SAAS,GAAG;AACV,UAAMZ,MAAM,GAAG,KAAKF,OAAL,CAAa,KAAKK,KAAlB,CAAf;;AAEA,QAAI;AACF,aAAOH,MAAM,CAACQ,KAAP,CAAa,KAAKN,MAAlB,CAAP;AACD,KAFD,CAEE,OAAOW,KAAP,EAAc;AACd,WAAKR,MAAL,CAAYS,IAAZ,CAAiBD,KAAjB;;AAEA,UAAI,KAAKV,KAAL,GAAa,CAAb,GAAiB,KAAKL,OAAL,CAAaY,MAAlC,EAA0C;AACxC,aAAKP,KAAL;AACA,aAAKD,MAAL,CAAYa,UAAZ,CAAuB,KAAKX,IAA5B;AACA,eAAO,KAAKQ,SAAL,EAAP;AACD;;AAED,WAAKI,UAAL;AACD;AACF;;AAEDA,EAAAA,UAAU,GAAG;AACX,UAAMC,aAAa,GAAG,KAAKZ,MAAL,CAAYa,MAAZ,CAAmB,CAACD,aAAD,EAAgBJ,KAAhB,KAA0B;AACjE,aAAOI,aAAa,CAACd,KAAd,GAAsBU,KAAK,CAACV,KAA5B,GAAoCc,aAApC,GAAoDJ,KAA3D;AACD,KAFqB,CAAtB;;AAIA,QAAII,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAMA,aAAN;AACD;AACF;;AAEDhB,EAAAA,KAAK,GAAE;AACL,WAAO,IAAIL,EAAJ,CAAO,KAAKE,OAAZ,CAAP;AACD;;AArEqB","sourcesContent":["export default class Or {\n  constructor(parsers) {\n    this.parsers = parsers.map(parser => parser.clone());\n    this.cursor = null;\n    this.index = 0;\n    this.mark = null;\n    this.errors = [];\n\n    this.assertParsers();\n  }\n\n  assertParsers() {\n    this.parsers.forEach(parser => {\n      if (typeof parser.parse !== \"function\") {\n        throw new Error(\n          \"Invalid Argument: An Alternation can only accept parsers.\"\n        );\n      }\n    });\n\n    if (this.parsers.length < 2) {\n      throw new Error(\n        \"Invalid Arguments: An Alternation needs at least two options.\"\n      );\n    }\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    return this.tryParser();\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.index = 0;\n    this.mark = this.cursor.mark();\n    this.errors = [];\n  }\n\n  tryParser() {\n    const parser = this.parsers[this.index];\n\n    try {\n      return parser.parse(this.cursor);\n    } catch (error) {\n      this.errors.push(error);\n\n      if (this.index + 1 < this.parsers.length) {\n        this.index++;\n        this.cursor.moveToMark(this.mark);\n        return this.tryParser();\n      }\n\n      this.throwError();\n    }\n  }\n\n  throwError() {\n    const furthestError = this.errors.reduce((furthestError, error) => {\n      return furthestError.index > error.index ? furthestError : error;\n    });\n\n    if (furthestError != null) {\n      throw furthestError;\n    }\n  }\n\n  clone(){\n    return new Or(this.parsers);\n  }\n}\n"],"file":"Or.js"}