{"version":3,"sources":["../../src/patterns/Or.js"],"names":["Or","constructor","parsers","options","map","parser","clone","cursor","index","mark","errors","assertParsers","recoverFromBadOptions","forEach","parse","Error","length","isOptional","reset","tryParser","error","push","moveToMark","throwError","furthestError","reduce"],"mappings":";;;;;;;AAAe,MAAMA,EAAN,CAAS;AACtBC,EAAAA,WAAW,CAACC,OAAD,EAAUC,OAAV,EAAmB;AAC5B,SAAKD,OAAL,GAAeA,OAAO,CAACE,GAAR,CAAYC,MAAM,IAAIA,MAAM,CAACC,KAAP,EAAtB,CAAf;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKI,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AAEA,SAAKC,aAAL;AACA,SAAKC,qBAAL;AACD;;AAEDD,EAAAA,aAAa,GAAG;AACd,SAAKT,OAAL,CAAaW,OAAb,CAAqBR,MAAM,IAAI;AAC7B,UAAI,OAAOA,MAAM,CAACS,KAAd,KAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF,KAND;;AAQA,QAAI,KAAKb,OAAL,CAAac,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAID,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;;AAEDH,EAAAA,qBAAqB,GAAG;AACtB,QAAI,OAAO,KAAKT,OAAZ,KAAwB,QAAxB,IAAoC,KAAKA,OAAL,IAAgB,IAAxD,EAA8D;AAC5D,WAAKA,OAAL,GAAe,EAAf;AACA,WAAKA,OAAL,CAAac,UAAb,GAA0B,KAA1B;AACD,KAHD,MAGO;AACL,UAAI,OAAO,KAAKd,OAAL,CAAac,UAApB,KAAmC,SAAvC,EAAkD;AAChD,aAAKd,OAAL,CAAac,UAAb,GAA0B,KAA1B;AACD;AACF;AACF;;AAEDH,EAAAA,KAAK,CAACP,MAAD,EAAS;AACZ,SAAKW,KAAL,CAAWX,MAAX;AACA,WAAO,KAAKY,SAAL,EAAP;AACD;;AAEDD,EAAAA,KAAK,CAACX,MAAD,EAAS;AACZ,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,KAAKF,MAAL,CAAYE,IAAZ,EAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACD;;AAEDS,EAAAA,SAAS,GAAG;AACV,UAAMd,MAAM,GAAG,KAAKH,OAAL,CAAa,KAAKM,KAAlB,CAAf;;AAEA,QAAI;AACF,aAAOH,MAAM,CAACS,KAAP,CAAa,KAAKP,MAAlB,CAAP;AACD,KAFD,CAEE,OAAOa,KAAP,EAAc;AACd,WAAKV,MAAL,CAAYW,IAAZ,CAAiBD,KAAjB;;AAEA,UAAI,KAAKZ,KAAL,GAAa,CAAb,GAAiB,KAAKN,OAAL,CAAac,MAAlC,EAA0C;AACxC,aAAKR,KAAL;AACA,aAAKD,MAAL,CAAYe,UAAZ,CAAuB,KAAKb,IAA5B;AACA,eAAO,KAAKU,SAAL,EAAP;AACD;;AAED,aAAO,KAAKI,UAAL,EAAP;AACD;AACF;;AAEDA,EAAAA,UAAU,GAAG;AACX,QAAI,KAAKpB,OAAL,CAAac,UAAjB,EAA6B;AAC3B,WAAKV,MAAL,CAAYe,UAAZ,CAAuB,KAAKb,IAA5B;AACA,aAAO,IAAP;AACD;;AAED,UAAMe,aAAa,GAAG,KAAKd,MAAL,CAAYe,MAAZ,CAAmB,CAACD,aAAD,EAAgBJ,KAAhB,KAA0B;AACjE,aAAOI,aAAa,CAAChB,KAAd,GAAsBY,KAAK,CAACZ,KAA5B,GAAoCgB,aAApC,GAAoDJ,KAA3D;AACD,KAFqB,CAAtB;;AAIA,QAAII,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAMA,aAAN;AACD;AACF;;AAEDlB,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIN,EAAJ,CAAO,KAAKE,OAAZ,CAAP;AACD;;AAvFqB","sourcesContent":["export default class Or {\n  constructor(parsers, options) {\n    this.parsers = parsers.map(parser => parser.clone());\n    this.options = options;\n    this.cursor = null;\n    this.index = 0;\n    this.mark = null;\n    this.errors = [];\n\n    this.assertParsers();\n    this.recoverFromBadOptions();\n  }\n\n  assertParsers() {\n    this.parsers.forEach(parser => {\n      if (typeof parser.parse !== \"function\") {\n        throw new Error(\n          \"Invalid Argument: An Alternation can only accept parsers.\"\n        );\n      }\n    });\n\n    if (this.parsers.length < 2) {\n      throw new Error(\n        \"Invalid Arguments: An Alternation needs at least two options.\"\n      );\n    }\n  }\n\n  recoverFromBadOptions() {\n    if (typeof this.options !== \"object\" || this.options == null) {\n      this.options = {};\n      this.options.isOptional = false;\n    } else {\n      if (typeof this.options.isOptional !== \"boolean\") {\n        this.options.isOptional = false;\n      }\n    }\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    return this.tryParser();\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.index = 0;\n    this.mark = this.cursor.mark();\n    this.errors = [];\n  }\n\n  tryParser() {\n    const parser = this.parsers[this.index];\n\n    try {\n      return parser.parse(this.cursor);\n    } catch (error) {\n      this.errors.push(error);\n\n      if (this.index + 1 < this.parsers.length) {\n        this.index++;\n        this.cursor.moveToMark(this.mark);\n        return this.tryParser();\n      }\n\n      return this.throwError();\n    }\n  }\n\n  throwError() {\n    if (this.options.isOptional) {\n      this.cursor.moveToMark(this.mark);\n      return null;\n    }\n\n    const furthestError = this.errors.reduce((furthestError, error) => {\n      return furthestError.index > error.index ? furthestError : error;\n    });\n\n    if (furthestError != null) {\n      throw furthestError;\n    }\n  }\n\n  clone() {\n    return new Or(this.parsers);\n  }\n}\n"],"file":"Or.js"}