{"version":3,"sources":["../../src/patterns/Literal.js"],"names":["Literal","constructor","name","value","assertValidity","isNullOrEmpty","Error","length","parse","cursor","match","x","character","getChar","charAt","ParseError","hasNext","next","ValueNode","clone"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,OAAN,CAAc;AAC3BC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;AACvB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AAEA,SAAKC,cAAL;AACD;;AAEDA,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKC,aAAL,CAAmB,KAAKF,KAAxB,CAAJ,EAAoC;AAClC,YAAM,IAAIG,KAAJ,CACJ,mFADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,aAAa,CAACF,KAAD,EAAQ;AACnB,WAAOA,KAAK,IAAI,IAAT,IAAkB,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACI,MAAN,KAAiB,CAAvE;AACD;;AAEDC,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,UAAMF,MAAM,GAAG,KAAKJ,KAAL,CAAWI,MAA1B;AACA,QAAIG,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,MAApB,EAA4BI,CAAC,EAA7B,EAAiC;AAC/B,YAAMC,SAAS,GAAGH,MAAM,CAACI,OAAP,EAAlB;;AAEA,UAAID,SAAS,KAAK,KAAKT,KAAL,CAAWW,MAAX,CAAkBH,CAAlB,CAAlB,EAAwC;AACtC,cAAM,IAAII,mBAAJ,CACH,gCAA+B,KAAKZ,KAAL,CAAWW,MAAX,CAC9BH,CAD8B,CAE9B,iBAAgBC,SAAU,GAHxB,CAAN;AAKD,OAND,MAMO;AACLF,QAAAA,KAAK,IAAIE,SAAT;AACD;;AAED,UAAIH,MAAM,CAACO,OAAP,EAAJ,EAAsB;AACpBP,QAAAA,MAAM,CAACQ,IAAP;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAED,QAAIP,KAAK,KAAK,KAAKP,KAAnB,EAA0B;AACxB,aAAO,IAAIe,kBAAJ,CAAc,KAAKhB,IAAnB,EAAyB,KAAKC,KAA9B,CAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIY,mBAAJ,CACH,gCAA+B,KAAKZ,KAAM,iBAAgBO,KAAM,GAD7D,CAAN;AAGD;AACF;;AAEDS,EAAAA,KAAK,GAAE;AACL,WAAO,IAAInB,OAAJ,CAAY,KAAKE,IAAjB,EAAuB,KAAKC,KAA5B,CAAP;AACD;;AAvD0B","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Literal {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n\n    this.assertValidity();\n  }\n\n  assertValidity() {\n    if (this.isNullOrEmpty(this.value)) {\n      throw new Error(\n        \"Illegal Argument: Literal needs to have a value that has a length greater than 0.\"\n      );\n    }\n  }\n\n  isNullOrEmpty(value) {\n    return value == null || (typeof value === \"string\" && value.length === 0);\n  }\n\n  parse(cursor) {\n    const length = this.value.length;\n    let match = \"\";\n\n    for (let x = 0; x < length; x++) {\n      const character = cursor.getChar();\n\n      if (character !== this.value.charAt(x)) {\n        throw new ParseError(\n          `Illegal character: expected '${this.value.charAt(\n            x\n          )}', but found '${character}'`\n        );\n      } else {\n        match += character;\n      }\n\n      if (cursor.hasNext()) {\n        cursor.next();\n      } else {\n        break;\n      }\n    }\n\n    if (match === this.value) {\n      return new ValueNode(this.name, this.value);\n    } else {\n      throw new ParseError(\n        `Illegal character: expected '${this.value}', but found '${match}'`\n      );\n    }\n  }\n\n  clone(){\n    return new Literal(this.name, this.value);\n  }\n}\n"],"file":"Literal.js"}