{"version":3,"sources":["../../src/patterns/Literal.js"],"names":["Literal","constructor","name","value","options","assertValidity","recoverFromBadOptions","isNullOrEmpty","Error","isOptional","length","parse","cursor","startIndex","getIndex","match","x","character","getChar","charAt","ParseError","hasNext","next","ValueNode","clone"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,OAAN,CAAc;AAC3BC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAcC,OAAd,EAAuB;AAChC,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,OAAL,GAAeA,OAAf;AAEA,SAAKC,cAAL;AACA,SAAKC,qBAAL;AACD;;AAEDD,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKE,aAAL,CAAmB,KAAKJ,KAAxB,CAAJ,EAAoC;AAClC,YAAM,IAAIK,KAAJ,CACJ,mFADI,CAAN;AAGD;AACF;;AAEDF,EAAAA,qBAAqB,GAAG;AACtB,QAAI,OAAO,KAAKF,OAAZ,KAAwB,QAAxB,IAAoC,KAAKA,OAAL,IAAgB,IAAxD,EAA8D;AAC5D,WAAKA,OAAL,GAAe,EAAf;AACA,WAAKA,OAAL,CAAaK,UAAb,GAA0B,KAA1B;AACD,KAHD,MAGO;AACL,UAAI,OAAO,KAAKL,OAAL,CAAaK,UAApB,KAAmC,SAAvC,EAAkD;AAChD,aAAKL,OAAL,CAAaK,UAAb,GAA0B,KAA1B;AACD;AACF;AACF;;AAEDF,EAAAA,aAAa,CAACJ,KAAD,EAAQ;AACnB,WAAOA,KAAK,IAAI,IAAT,IAAkB,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACO,MAAN,KAAiB,CAAvE;AACD;;AAEDC,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,UAAMC,UAAU,GAAGD,MAAM,CAACE,QAAP,EAAnB;AACA,UAAMJ,MAAM,GAAG,KAAKP,KAAL,CAAWO,MAA1B;AACA,QAAIK,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAApB,EAA4BM,CAAC,EAA7B,EAAiC;AAC/B,YAAMC,SAAS,GAAGL,MAAM,CAACM,OAAP,EAAlB;;AAEA,UAAID,SAAS,KAAK,KAAKd,KAAL,CAAWgB,MAAX,CAAkBH,CAAlB,CAAlB,EAAwC;AACtC,YAAI,KAAKZ,OAAL,CAAaK,UAAjB,EAA6B;AAC3B,iBAAO,IAAP;AACD,SAFD,MAEO;AACL,gBAAM,IAAIW,mBAAJ,CACH,gCAA+B,KAAKjB,KAAL,CAAWgB,MAAX,CAC9BH,CAD8B,CAE9B,iBAAgBC,SAAU,GAHxB,CAAN;AAKD;AACF,OAVD,MAUO;AACLF,QAAAA,KAAK,IAAIE,SAAT;AACD;;AAED,UAAIL,MAAM,CAACS,OAAP,EAAJ,EAAsB;AACpBT,QAAAA,MAAM,CAACU,IAAP;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAED,QAAIP,KAAK,KAAK,KAAKZ,KAAnB,EAA0B;AACxB,aAAO,IAAIoB,kBAAJ,CACL,KAAKrB,IADA,EAEL,KAAKC,KAFA,EAGLU,UAHK,EAILA,UAAU,GAAG,KAAKV,KAAL,CAAWO,MAAxB,GAAiC,CAJ5B,CAAP;AAMD,KAPD,MAOO;AACL,UAAI,KAAKN,OAAL,CAAaK,UAAjB,EAA6B;AAC3B,eAAO,IAAP;AACD,OAFD,MAEO;AACL,cAAM,IAAIW,mBAAJ,CACH,gCAA+B,KAAKjB,KAAM,iBAAgBY,KAAM,GAD7D,CAAN;AAGD;AACF;AACF;;AAEDS,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIxB,OAAJ,CAAY,KAAKE,IAAjB,EAAuB,KAAKC,KAA5B,EAAmC,KAAKC,OAAxC,CAAP;AACD;;AAlF0B","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Literal {\n  constructor(name, value, options) {\n    this.name = name;\n    this.value = value;\n    this.options = options;\n\n    this.assertValidity();\n    this.recoverFromBadOptions();\n  }\n\n  assertValidity() {\n    if (this.isNullOrEmpty(this.value)) {\n      throw new Error(\n        \"Illegal Argument: Literal needs to have a value that has a length greater than 0.\"\n      );\n    }\n  }\n\n  recoverFromBadOptions() {\n    if (typeof this.options !== \"object\" || this.options == null) {\n      this.options = {};\n      this.options.isOptional = false;\n    } else {\n      if (typeof this.options.isOptional !== \"boolean\") {\n        this.options.isOptional = false;\n      }\n    }\n  }\n\n  isNullOrEmpty(value) {\n    return value == null || (typeof value === \"string\" && value.length === 0);\n  }\n\n  parse(cursor) {\n    const startIndex = cursor.getIndex();\n    const length = this.value.length;\n    let match = \"\";\n\n    for (let x = 0; x < length; x++) {\n      const character = cursor.getChar();\n\n      if (character !== this.value.charAt(x)) {\n        if (this.options.isOptional) {\n          return null;\n        } else {\n          throw new ParseError(\n            `Illegal character: expected '${this.value.charAt(\n              x\n            )}', but found '${character}'`\n          );\n        }\n      } else {\n        match += character;\n      }\n\n      if (cursor.hasNext()) {\n        cursor.next();\n      } else {\n        break;\n      }\n    }\n\n    if (match === this.value) {\n      return new ValueNode(\n        this.name,\n        this.value,\n        startIndex,\n        startIndex + this.value.length - 1\n      );\n    } else {\n      if (this.options.isOptional) {\n        return null;\n      } else {\n        throw new ParseError(\n          `Illegal character: expected '${this.value}', but found '${match}'`\n        );\n      }\n    }\n  }\n\n  clone() {\n    return new Literal(this.name, this.value, this.options);\n  }\n}\n"],"file":"Literal.js"}