{"version":3,"sources":["../../src/patterns/Literal.js"],"names":["Literal","constructor","name","value","assertValidity","isNullOrEmpty","Error","length","parse","cursor","startIndex","getIndex","match","x","character","getChar","charAt","ParseError","hasNext","next","ValueNode","clone"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,OAAN,CAAc;AAC3BC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;AACvB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,KAAL,GAAaA,KAAb;AAEA,SAAKC,cAAL;AACD;;AAEDA,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKC,aAAL,CAAmB,KAAKF,KAAxB,CAAJ,EAAoC;AAClC,YAAM,IAAIG,KAAJ,CACJ,mFADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,aAAa,CAACF,KAAD,EAAQ;AACnB,WAAOA,KAAK,IAAI,IAAT,IAAkB,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACI,MAAN,KAAiB,CAAvE;AACD;;AAEDC,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,UAAMC,UAAU,GAAGD,MAAM,CAACE,QAAP,EAAnB;AACA,UAAMJ,MAAM,GAAG,KAAKJ,KAAL,CAAWI,MAA1B;AACA,QAAIK,KAAK,GAAG,EAAZ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAApB,EAA4BM,CAAC,EAA7B,EAAiC;AAC/B,YAAMC,SAAS,GAAGL,MAAM,CAACM,OAAP,EAAlB;;AAEA,UAAID,SAAS,KAAK,KAAKX,KAAL,CAAWa,MAAX,CAAkBH,CAAlB,CAAlB,EAAwC;AACtC,cAAM,IAAII,mBAAJ,CACH,gCAA+B,KAAKd,KAAL,CAAWa,MAAX,CAC9BH,CAD8B,CAE9B,iBAAgBC,SAAU,GAHxB,CAAN;AAKD,OAND,MAMO;AACLF,QAAAA,KAAK,IAAIE,SAAT;AACD;;AAED,UAAIL,MAAM,CAACS,OAAP,EAAJ,EAAsB;AACpBT,QAAAA,MAAM,CAACU,IAAP;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAED,QAAIP,KAAK,KAAK,KAAKT,KAAnB,EAA0B;AACxB,aAAO,IAAIiB,kBAAJ,CACL,KAAKlB,IADA,EAEL,KAAKC,KAFA,EAGLO,UAHK,EAILA,UAAU,GAAG,KAAKP,KAAL,CAAWI,MAAxB,GAAiC,CAJ5B,CAAP;AAMD,KAPD,MAOO;AACL,YAAM,IAAIU,mBAAJ,CACH,gCAA+B,KAAKd,KAAM,iBAAgBS,KAAM,GAD7D,CAAN;AAGD;AACF;;AAEDS,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIrB,OAAJ,CAAY,KAAKE,IAAjB,EAAuB,KAAKC,KAA5B,CAAP;AACD;;AA7D0B","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Literal {\n  constructor(name, value) {\n    this.name = name;\n    this.value = value;\n\n    this.assertValidity();\n  }\n\n  assertValidity() {\n    if (this.isNullOrEmpty(this.value)) {\n      throw new Error(\n        \"Illegal Argument: Literal needs to have a value that has a length greater than 0.\"\n      );\n    }\n  }\n\n  isNullOrEmpty(value) {\n    return value == null || (typeof value === \"string\" && value.length === 0);\n  }\n\n  parse(cursor) {\n    const startIndex = cursor.getIndex();\n    const length = this.value.length;\n    let match = \"\";\n\n    for (let x = 0; x < length; x++) {\n      const character = cursor.getChar();\n\n      if (character !== this.value.charAt(x)) {\n        throw new ParseError(\n          `Illegal character: expected '${this.value.charAt(\n            x\n          )}', but found '${character}'`\n        );\n      } else {\n        match += character;\n      }\n\n      if (cursor.hasNext()) {\n        cursor.next();\n      } else {\n        break;\n      }\n    }\n\n    if (match === this.value) {\n      return new ValueNode(\n        this.name,\n        this.value,\n        startIndex,\n        startIndex + this.value.length - 1\n      );\n    } else {\n      throw new ParseError(\n        `Illegal character: expected '${this.value}', but found '${match}'`\n      );\n    }\n  }\n\n  clone() {\n    return new Literal(this.name, this.value);\n  }\n}\n"],"file":"Literal.js"}