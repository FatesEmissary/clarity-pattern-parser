{"version":3,"sources":["../../../src/patterns/composite/AndComposite.js"],"names":["AndComposite","name","patterns","_assertArguments","_children","length","Error","cursor","index","nodes","node","mark","_reset","_assertCursor","_tryPatterns","Cursor","pattern","parse","hasUnresolvedError","moveToMark","push","_next","_processValue","_hasMorePatterns","hasNext","next","_assertRestOfPatternsAreOptional","areTheRestOptional","children","every","OptionalValue","OptionalComposite","parseError","ParseError","throwError","filter","lastNode","startIndex","endIndex","CompositeNode","setIndex","CompositePattern"],"mappings":"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","sourcesContent":["import CompositePattern from \"./CompositePattern.js\";\nimport CompositeNode from \"../../ast/CompositeNode.js\";\nimport Cursor from \"../../Cursor.js\";\nimport ParseError from \"../../patterns/ParseError.js\";\nimport StackInformation from \"../StackInformation.js\";\nimport OptionalValue from \"../value/OptionalValue.js\";\nimport OptionalComposite from \"./OptionalComposite.js\";\n\nexport default class AndComposite extends CompositePattern {\n  constructor(name, patterns) {\n    super(name, patterns);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._children.length < 2) {\n      throw new Error(\n        \"Invalid Argument: AndValue needs to have more than one value pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor) {\n    this.index = 0;\n    this.nodes = [];\n    this.node = null;\n    this.cursor = cursor;\n    this.mark = this.cursor.mark();\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._assertCursor();\n    this._tryPatterns();\n\n    return this.node;\n  }\n\n  _assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  _tryPatterns() {\n    while (true) {\n      const pattern = this._children[this.index];\n      const node = pattern.parse(this.cursor);\n\n      if (this.cursor.hasUnresolvedError()) {\n        this.cursor.moveToMark(this.mark);\n        break;\n      } else {\n        this.nodes.push(node);\n      }\n\n      if (!this._next()) {\n        this._processValue();\n        break;\n      }\n    }\n  }\n\n  _next() {\n    if (this._hasMorePatterns()) {\n      if (this.cursor.hasNext()) {\n        // If the last result was a failed optional, then don't increment the cursor.\n        if (this.nodes[this.nodes.length - 1] != null) {\n          this.cursor.next();\n        }\n\n        this.index++;\n        return true;\n      } else if (this.nodes[this.nodes.length - 1] == null) {\n        this.index++;\n        return true;\n      }\n\n      this._assertRestOfPatternsAreOptional();\n      return false;\n    } else {\n      return false;\n    }\n  }\n\n  _hasMorePatterns() {\n    return this.index + 1 < this._children.length;\n  }\n\n  _assertRestOfPatternsAreOptional() {\n    const areTheRestOptional = this.children.every((pattern, index) => {\n      return (\n        index <= this.index ||\n        pattern instanceof OptionalValue ||\n        pattern instanceof OptionalComposite\n      );\n    });\n\n    if (!areTheRestOptional) {\n      const parseError = new ParseError(\n        `Could not match ${this.name} before string ran out.`,\n        this.index,\n        this\n      );\n      this.cursor.throwError(parseError);\n    }\n  }\n\n  _processValue() {\n    if (!this.cursor.hasUnresolvedError()) {\n      this.nodes = this.nodes.filter(node => node != null);\n\n      const lastNode = this.nodes[this.nodes.length - 1];\n      const startIndex = this.mark.index;\n      const endIndex = lastNode.endIndex;\n\n      this.node = new CompositeNode(this.name, startIndex, endIndex);\n      this.node.children = this.nodes;\n\n      this.cursor.setIndex(this.node.endIndex);\n    } else {\n      this.node = null;\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new AndComposite(name, this._children);\n  }\n\n  getCurrentMark() {\n    return this.mark;\n  }\n}\n"],"file":"AndComposite.js"}