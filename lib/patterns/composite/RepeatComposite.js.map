{"version":3,"sources":["../../../src/patterns/composite/RepeatComposite.js"],"names":["RepeatComposite","name","pattern","divider","_pattern","children","_divider","_assertArguments","OptionalComposite","Error","cursor","parseError","mark","nodes","ParseError","_reset","_tryPattern","node","push","parse","next","error","moveToMark","_processMatch","length","index","CompositeNode","startIndex","endIndex","setIndex","CompositePattern"],"mappings":"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","sourcesContent":["import CompositePattern from \"./CompositePattern.js\";\nimport CompositeNode from \"../../ast/CompositeNode.js\";\nimport ParseError from \"../ParseError.js\";\nimport OptionalComposite from \"./OptionalComposite.js\";\n\nexport default class RepeatComposite extends CompositePattern {\n  constructor(name, pattern, divider) {\n    super(name, divider != null ? [pattern, divider] : [pattern]);\n\n    this._pattern = this.children[0];\n    this._divider = this.children[1];\n\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._pattern instanceof OptionalComposite) {\n      throw new Error(\n        \"Invalid Arguments: The pattern cannot be a optional pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor, parseError) {\n    this.cursor = null;\n    this.mark = null;\n    this.nodes = [];\n    this.parseError = parseError;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n\n    if (parseError == null) {\n      this.parseError = new ParseError();\n    }\n  }\n\n  parse(cursor, parseError) {\n    this._reset(cursor, parseError);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      try {\n        this.nodes.push(this._pattern.parse(this.cursor, this.parseError));\n        this.cursor.next();\n\n        if (this._divider != null) {\n          const mark = this.cursor.mark();\n          try {\n            this.nodes.push(this._divider.parse(this.cursor));\n            this.cursor.next();\n          } catch (error) {\n            this.cursor.moveToMark(mark);\n            this._processMatch();\n            break;\n          }\n        }\n      } catch (error) {\n        this._processMatch();\n        break;\n      }\n    }\n  }\n\n  _processMatch() {\n    if (this.nodes.length === 0) {\n      throw new ParseError(\n        `Did not find a repeating match of ${this.name}.`,\n        this.mark.index,\n        this\n      );\n    } else {\n      this.node = new CompositeNode(\n        this.name,\n        this.nodes[0].startIndex,\n        this.nodes[this.nodes.length - 1].endIndex\n      );\n\n      this.node.children = this.nodes;\n      this.cursor.setIndex(this.node.endIndex);\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new RepeatComposite(name, this._pattern, this._divider);\n  }\n\n  getCurrentMark() {\n    return this.mark;\n  }\n}\n"],"file":"RepeatComposite.js"}