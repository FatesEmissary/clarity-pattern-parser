{"version":3,"sources":["../../../src/patterns/composite/RepeatComposite.js"],"names":["RepeatComposite","name","pattern","divider","_pattern","children","_divider","_assertArguments","_reset","OptionalComposite","Error","cursor","mark","nodes","_tryPattern","node","push","parse","next","error","moveToMark","_processMatch","length","ParseError","index","CompositeNode","startIndex","endIndex","setIndex","CompositePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,e;;;;;AACnB,2BAAYC,IAAZ,EAAkBC,OAAlB,EAA2BC,OAA3B,EAAoC;AAAA;;AAAA;;AAClC,yFAAMF,IAAN,EAAYE,OAAO,IAAI,IAAX,GAAkB,CAACD,OAAD,EAAUC,OAAV,CAAlB,GAAuC,CAACD,OAAD,CAAnD;AAEA,UAAKE,QAAL,GAAgB,MAAKC,QAAL,CAAc,CAAd,CAAhB;AACA,UAAKC,QAAL,GAAgB,MAAKD,QAAL,CAAc,CAAd,CAAhB;;AAEA,UAAKE,gBAAL;;AACA,UAAKC,MAAL;;AAPkC;AAQnC;;;;uCAEkB;AACjB,UAAI,KAAKJ,QAAL,YAAyBK,0BAA7B,EAAgD;AAC9C,cAAM,IAAIC,KAAJ,CACJ,8DADI,CAAN;AAGD;AACF;;;2BAEMC,M,EAAQ;AACb,WAAKA,MAAL,GAAc,IAAd;AACA,WAAKC,IAAL,GAAY,IAAZ;AACA,WAAKC,KAAL,GAAa,EAAb;;AAEA,UAAIF,MAAM,IAAI,IAAd,EAAoB;AAClB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKC,IAAL,GAAY,KAAKD,MAAL,CAAYC,IAAZ,EAAZ;AACD;AACF;;;0BAEKD,M,EAAQ;AACZ,WAAKH,MAAL,CAAYG,MAAZ;;AACA,WAAKG,WAAL;;AAEA,aAAO,KAAKC,IAAZ;AACD;;;kCAEa;AACZ,aAAO,IAAP,EAAa;AACX,YAAI;AACF,eAAKF,KAAL,CAAWG,IAAX,CAAgB,KAAKZ,QAAL,CAAca,KAAd,CAAoB,KAAKN,MAAzB,CAAhB;AACA,eAAKA,MAAL,CAAYO,IAAZ;;AAEA,cAAI,KAAKZ,QAAL,IAAiB,IAArB,EAA2B;AACzB,gBAAMM,IAAI,GAAG,KAAKD,MAAL,CAAYC,IAAZ,EAAb;;AACA,gBAAG;AACD,mBAAKC,KAAL,CAAWG,IAAX,CAAgB,KAAKV,QAAL,CAAcW,KAAd,CAAoB,KAAKN,MAAzB,CAAhB;AACA,mBAAKA,MAAL,CAAYO,IAAZ;AACD,aAHD,CAGE,OAAMC,KAAN,EAAY;AACZ,mBAAKR,MAAL,CAAYS,UAAZ,CAAuBR,IAAvB;;AACA,mBAAKS,aAAL;;AACA;AACD;AACF;AACF,SAfD,CAeE,OAAOF,KAAP,EAAc;AACd,eAAKE,aAAL;;AACA;AACD;AACF;AACF;;;oCAEe;AACd,UAAI,KAAKR,KAAL,CAAWS,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,cAAM,IAAIC,mBAAJ,6CACiC,KAAKtB,IADtC,QAEJ,KAAKW,IAAL,CAAUY,KAFN,EAGJ,IAHI,CAAN;AAKD,OAND,MAMO;AACL,aAAKT,IAAL,GAAY,IAAIU,sBAAJ,CACV,KAAKxB,IADK,EAEV,KAAKY,KAAL,CAAW,CAAX,EAAca,UAFJ,EAGV,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWS,MAAX,GAAoB,CAA/B,EAAkCK,QAHxB,CAAZ;AAMA,aAAKZ,IAAL,CAAUV,QAAV,GAAqB,KAAKQ,KAA1B;AACA,aAAKF,MAAL,CAAYiB,QAAZ,CAAqB,KAAKb,IAAL,CAAUY,QAA/B;AACD;AACF;;;4BAEO;AACN,aAAO,IAAI3B,eAAJ,CAAoB,KAAKC,IAAzB,EAA+B,KAAKG,QAApC,EAA8C,KAAKE,QAAnD,CAAP;AACD;;;;EAlF0CuB,0B","sourcesContent":["import CompositePattern from \"./CompositePattern.js\";\nimport CompositeNode from \"../../ast/CompositeNode.js\";\nimport ParseError from \"../ParseError.js\";\nimport OptionalComposite from \"./OptionalComposite.js\";\n\nexport default class RepeatComposite extends CompositePattern {\n  constructor(name, pattern, divider) {\n    super(name, divider != null ? [pattern, divider] : [pattern]);\n\n    this._pattern = this.children[0];\n    this._divider = this.children[1];\n\n    this._assertArguments();\n    this._reset();\n  }\n\n  _assertArguments() {\n    if (this._pattern instanceof OptionalComposite) {\n      throw new Error(\n        \"Invalid Arguments: The pattern cannot be a optional pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor) {\n    this.cursor = null;\n    this.mark = null;\n    this.nodes = [];\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      try {\n        this.nodes.push(this._pattern.parse(this.cursor));\n        this.cursor.next();\n\n        if (this._divider != null) {\n          const mark = this.cursor.mark();\n          try{\n            this.nodes.push(this._divider.parse(this.cursor));\n            this.cursor.next();\n          } catch(error){\n            this.cursor.moveToMark(mark);\n            this._processMatch();\n            break;\n          }\n        }\n      } catch (error) {\n        this._processMatch();\n        break;\n      }\n    }\n  }\n\n  _processMatch() {\n    if (this.nodes.length === 0) {\n      throw new ParseError(\n        `Did not find a repeating match of ${this.name}.`,\n        this.mark.index,\n        this\n      );\n    } else {\n      this.node = new CompositeNode(\n        this.name,\n        this.nodes[0].startIndex,\n        this.nodes[this.nodes.length - 1].endIndex\n      );\n\n      this.node.children = this.nodes;\n      this.cursor.setIndex(this.node.endIndex);\n    }\n  }\n\n  clone() {\n    return new RepeatComposite(this.name, this._pattern, this._divider);\n  }\n}\n"],"file":"RepeatComposite.js"}