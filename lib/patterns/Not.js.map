{"version":3,"sources":["../../src/patterns/Not.js"],"names":["Not","constructor","name","value","literal","Literal","notMatchingValue","parse","cursor","reset","tryLiteral","mark","moveToMark","length","ValueNode","ParseError","error","getChar","hasNext","next","clone"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEe,MAAMA,GAAN,CAAU;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,KAAP,EAAc;AACvB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKE,OAAL,GAAe,IAAIC,gBAAJ,CAAYH,IAAZ,EAAkBC,KAAlB,CAAf;AACA,SAAKG,gBAAL,GAAwBH,KAAxB;AACA,SAAKA,KAAL,GAAa,EAAb;AACD;;AAEDI,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,SAAKC,KAAL,CAAWD,MAAX;AACA,WAAO,KAAKE,UAAL,EAAP;AACD;;AAEDD,EAAAA,KAAK,CAACD,MAAD,EAAS;AACZ,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKL,KAAL,GAAa,EAAb;AACD;;AAEDO,EAAAA,UAAU,GAAG;AACX,UAAMC,IAAI,GAAG,KAAKH,MAAL,CAAYG,IAAZ,EAAb;;AAEA,QAAI;AACF,WAAKP,OAAL,CAAaG,KAAb,CAAmB,KAAKC,MAAxB;AACA,WAAKA,MAAL,CAAYI,UAAZ,CAAuBD,IAAvB;;AAEA,UAAI,KAAKR,KAAL,CAAWU,MAAX,GAAoB,CAAxB,EAA2B;AACzB,eAAO,IAAIC,kBAAJ,CAAc,KAAKZ,IAAnB,EAAyB,KAAKC,KAA9B,CAAP;AACD,OAFD,MAEO;AACL,cAAM,IAAIY,mBAAJ,CACH,uCAAsC,KAAKT,gBAAiB,IADzD,CAAN;AAGD;AACF,KAXD,CAWE,OAAOU,KAAP,EAAc;AACd,WAAKb,KAAL,IAAc,KAAKK,MAAL,CAAYS,OAAZ,EAAd;;AAEA,UAAI,KAAKT,MAAL,CAAYU,OAAZ,EAAJ,EAA2B;AACzB,aAAKV,MAAL,CAAYW,IAAZ;AACA,eAAO,KAAKT,UAAL,EAAP;AACD,OAHD,MAGQ;AACN,eAAO,IAAII,kBAAJ,CAAc,KAAKZ,IAAnB,EAAyB,KAAKC,KAA9B,CAAP;AACD;AACF;AACF;;AAEDiB,EAAAA,KAAK,GAAE;AACL,WAAO,IAAIpB,GAAJ,CAAQ,KAAKE,IAAb,EAAmB,KAAKI,gBAAxB,CAAP;AACD;;AA9CsB","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport Literal from \"./Literal.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Not {\n  constructor(name, value) {\n    this.name = name;\n    this.literal = new Literal(name, value);\n    this.notMatchingValue = value;\n    this.value = \"\";\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    return this.tryLiteral();\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.value = \"\";\n  }\n\n  tryLiteral() {\n    const mark = this.cursor.mark();\n\n    try {\n      this.literal.parse(this.cursor);\n      this.cursor.moveToMark(mark);\n\n      if (this.value.length > 0) {\n        return new ValueNode(this.name, this.value);\n      } else {\n        throw new ParseError(\n          `Couldn't find pattern not matching '${this.notMatchingValue}'.`\n        );\n      }\n    } catch (error) {\n      this.value += this.cursor.getChar();\n\n      if (this.cursor.hasNext()) {\n        this.cursor.next();\n        return this.tryLiteral();\n      }  else {\n        return new ValueNode(this.name, this.value);\n      }\n    }\n  }\n\n  clone(){\n    return new Not(this.name, this.notMatchingValue);\n  }\n}\n"],"file":"Not.js"}