{"version":3,"sources":["../../src/patterns/Not.js"],"names":["Not","constructor","name","parser","options","value","startingMark","assertParser","recoverFromBadOptions","parse","Error","isOptional","cursor","reset","tryParser","mark","moveToMark","length","ValueNode","index","ParseError","error","getChar","hasNext","next","clone"],"mappings":"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","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Not {\n  constructor(name, parser, options) {\n    this.name = name;\n    this.parser = parser;\n    this.options = options;\n    this.value = \"\";\n    this.startingMark = null;\n\n    this.assertParser();\n    this.recoverFromBadOptions();\n  }\n\n  assertParser() {\n    if (\n      this.parser == null ||\n      (this.parser && typeof this.parser.parse !== \"function\")\n    ) {\n      throw new Error(\n        \"Invalid Arguments: Expected a 'parser' to have a parse function.\"\n      );\n    }\n  }\n\n  recoverFromBadOptions() {\n    if (typeof this.options !== \"object\" || this.options == null) {\n      this.options = {};\n      this.options.isOptional = false;\n    } else {\n      if (typeof this.options.isOptional !== \"boolean\") {\n        this.options.isOptional = false;\n      }\n    }\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    return this.tryParser();\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.startingMark = this.cursor.mark();\n    this.value = \"\";\n  }\n\n  tryParser() {\n    const mark = this.cursor.mark();\n\n    try {\n      this.parser.parse(this.cursor);\n      this.cursor.moveToMark(mark);\n\n      if (this.value.length > 0) {\n        return new ValueNode(\n          this.name,\n          this.value,\n          this.startingMark.index,\n          this.startingMark.index + this.value.length - 1\n        );\n      } else {\n        if (this.options.isOptional) {\n          return null;\n        }\n        throw new ParseError(\n          `Couldn't find pattern not matching '${this.parser.name}' parser.`\n        );\n      }\n    } catch (error) {\n      this.cursor.moveToMark(mark);\n      this.value += this.cursor.getChar();\n\n      if (this.cursor.hasNext()) {\n        this.cursor.next();\n        return this.tryParser();\n      } else {\n        return new ValueNode(\n          this.name,\n          this.value,\n          this.startingMark.index,\n          this.startingMark.index + this.value.length - 1\n        );\n      }\n    }\n  }\n\n  clone() {\n    return new Not(this.name, this.parser, this.options);\n  }\n}\n"],"file":"Not.js"}