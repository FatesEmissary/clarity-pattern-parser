{"version":3,"sources":["../../src/patterns/Any.js"],"names":["Any","constructor","name","parsers","map","parser","clone","cursor","index","mark","errors","nodes","value","assertParsers","forEach","parse","Error","length","reset","tryParser","reduceValue","ValueNode","startIndex","endIndex","node","push","lastIndex","next","error","moveToMark","throwError","furthestError","reduce","ParseError","join"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,GAAN,CAAU;AACvBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACzB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAO,CAACC,GAAR,CAAYC,MAAM,IAAIA,MAAM,CAACC,KAAP,EAAtB,CAAf;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,KAAL,GAAa,IAAb;AAEA,SAAKC,aAAL;AACD;;AAEDA,EAAAA,aAAa,GAAG;AACd,SAAKV,OAAL,CAAaW,OAAb,CAAqBT,MAAM,IAAI;AAC7B,UAAI,OAAOA,MAAM,CAACU,KAAd,KAAwB,UAA5B,EAAwC;AACtC,cAAM,IAAIC,KAAJ,CACJ,2DADI,CAAN;AAGD;AACF,KAND;;AAQA,QAAI,KAAKb,OAAL,CAAac,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,IAAID,KAAJ,CACJ,+DADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,KAAK,CAACR,MAAD,EAAS;AACZ,SAAKW,KAAL,CAAWX,MAAX;AACA,SAAKY,SAAL;AACA,SAAKC,WAAL;AAEA,WAAO,IAAIC,kBAAJ,CACL,KAAKnB,IADA,EAEL,KAAKU,KAFA,EAGL,KAAKD,KAAL,CAAW,CAAX,EAAcW,UAHT,EAIL,KAAKX,KAAL,CAAW,KAAKA,KAAL,CAAWM,MAAX,GAAkB,CAA7B,EAAgCM,QAJ3B,CAAP;AAMD;;AAEDL,EAAAA,KAAK,CAACX,MAAD,EAAS;AACZ,SAAKA,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,IAAL,GAAY,KAAKF,MAAL,CAAYE,IAAZ,EAAZ;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKE,KAAL,GAAa,IAAb;AACD;;AAEDO,EAAAA,SAAS,GAAG;AACV,UAAMd,MAAM,GAAG,KAAKF,OAAL,CAAa,KAAKK,KAAlB,CAAf;;AAEA,QAAI;AACF,YAAMgB,IAAI,GAAGnB,MAAM,CAACU,KAAP,CAAa,KAAKR,MAAlB,CAAb;;AAEA,UAAI,EAAEiB,IAAI,YAAYH,kBAAlB,CAAJ,EAAkC;AAChC,cAAM,IAAIL,KAAJ,CACH,gHAA+GX,MAAM,CAACH,IAAK,UADxH,CAAN;AAGD;;AAED,WAAKS,KAAL,CAAWc,IAAX,CAAgBD,IAAhB;AAEA,WAAKhB,KAAL,GAAa,CAAb;AACA,WAAKE,MAAL,GAAc,EAAd;;AAEA,UAAIc,IAAI,CAACD,QAAL,KAAkB,KAAKhB,MAAL,CAAYmB,SAAZ,EAAtB,EAA+C;AAC7C,aAAKjB,IAAL,GAAY,KAAKF,MAAL,CAAYE,IAAZ,EAAZ;AACA,aAAKF,MAAL,CAAYoB,IAAZ;AACA,aAAKR,SAAL;AACD;AACF,KAnBD,CAmBE,OAAOS,KAAP,EAAc;AACd,WAAKlB,MAAL,CAAYe,IAAZ,CAAiBG,KAAjB;;AAEA,UAAI,KAAKpB,KAAL,GAAa,CAAb,GAAiB,KAAKL,OAAL,CAAac,MAAlC,EAA0C;AACxC,aAAKT,KAAL;AACA,aAAKD,MAAL,CAAYsB,UAAZ,CAAuB,KAAKpB,IAA5B;AACA,eAAO,KAAKU,SAAL,EAAP;AACD;;AAED,WAAKW,UAAL;AACD;AACF;;AAEDA,EAAAA,UAAU,GAAG;AACX,UAAMC,aAAa,GAAG,KAAKrB,MAAL,CAAYsB,MAAZ,CAAmB,CAACD,aAAD,EAAgBH,KAAhB,KAA0B;AACjE,aAAOG,aAAa,CAACvB,KAAd,GAAsBoB,KAAK,CAACpB,KAA5B,GAAoCuB,aAApC,GAAoDH,KAA3D;AACD,KAFqB,CAAtB;;AAIA,QAAIG,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAMA,aAAN;AACD;AACF;;AAEDX,EAAAA,WAAW,GAAG;AACZ,QAAI,KAAKT,KAAL,CAAWM,MAAX,GAAoB,CAAxB,EAA2B;AACzB,YAAM,IAAIgB,mBAAJ,CAAgB,6BAA4B,KAAK/B,IAAK,GAAtD,CAAN;AACD;;AAED,SAAKU,KAAL,GAAa,KAAKD,KAAL,CAAWP,GAAX,CAAeoB,IAAI,IAAIA,IAAI,CAACZ,KAA5B,EAAmCsB,IAAnC,CAAwC,EAAxC,CAAb;AACD;;AAED5B,EAAAA,KAAK,GAAG;AACN,WAAO,IAAIN,GAAJ,CAAQ,KAAKE,IAAb,EAAmB,KAAKC,OAAxB,CAAP;AACD;;AA1GsB","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class Any {\n  constructor(name, parsers) {\n    this.name = name;\n    this.parsers = parsers.map(parser => parser.clone());\n    this.cursor = null;\n    this.index = 0;\n    this.mark = null;\n    this.errors = [];\n    this.nodes = [];\n    this.value = null;\n\n    this.assertParsers();\n  }\n\n  assertParsers() {\n    this.parsers.forEach(parser => {\n      if (typeof parser.parse !== \"function\") {\n        throw new Error(\n          \"Invalid Argument: An Alternation can only accept parsers.\"\n        );\n      }\n    });\n\n    if (this.parsers.length < 2) {\n      throw new Error(\n        \"Invalid Arguments: An Alternation needs at least two options.\"\n      );\n    }\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.tryParser();\n    this.reduceValue();\n\n    return new ValueNode(\n      this.name,\n      this.value,\n      this.nodes[0].startIndex,\n      this.nodes[this.nodes.length-1].endIndex \n    );\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.index = 0;\n    this.mark = this.cursor.mark();\n    this.errors = [];\n    this.value = null;\n  }\n\n  tryParser() {\n    const parser = this.parsers[this.index];\n\n    try {\n      const node = parser.parse(this.cursor);\n\n      if (!(node instanceof ValueNode)) {\n        throw new Error(\n          `Invalid Arguments: 'Any Parser' expects all parsers to return a Value node, but received something else on a ${parser.name} parser.`\n        );\n      }\n\n      this.nodes.push(node);\n\n      this.index = 0;\n      this.errors = [];\n\n      if (node.endIndex !== this.cursor.lastIndex()) {\n        this.mark = this.cursor.mark();\n        this.cursor.next();\n        this.tryParser();\n      }\n    } catch (error) {\n      this.errors.push(error);\n\n      if (this.index + 1 < this.parsers.length) {\n        this.index++;\n        this.cursor.moveToMark(this.mark);\n        return this.tryParser();\n      }\n\n      this.throwError();\n    }\n  }\n\n  throwError() {\n    const furthestError = this.errors.reduce((furthestError, error) => {\n      return furthestError.index > error.index ? furthestError : error;\n    });\n\n    if (furthestError != null) {\n      throw furthestError;\n    }\n  }\n\n  reduceValue() {\n    if (this.nodes.length < 1) {\n      throw new ParseError(`Couldn't find a match for ${this.name}.`);\n    }\n\n    this.value = this.nodes.map(node => node.value).join(\"\");\n  }\n\n  clone() {\n    return new Any(this.name, this.parsers);\n  }\n}\n"],"file":"Any.js"}