{"version":3,"sources":["../../src/patterns/OneOf.js"],"names":["OneOf","constructor","name","values","min","max","cursor","match","Infinity","assertValidity","isNullOrEmpty","Error","value","length","isMatch","indexOf","getChar","reset","parse","startIndex","getIndex","hasNext","next","ParseError","endIndex","ValueNode","clone"],"mappings":";;;;;;;AAAA;;AACA;;;;AAEe,MAAMA,KAAN,CAAY;AACzBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,MAAP,EAAe;AAAEC,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAe,EAA9B,EAAkC;AAC3C,SAAKH,IAAL,GAAYA,IAAZ;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKG,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKF,GAAL,GAAW,OAAOA,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCG,QAA3C;AACA,SAAKJ,GAAL,GAAW,OAAOA,GAAP,KAAe,WAAW,CAA1B,GAA8BA,GAA9B,GAAoC,CAA/C;AAEA,SAAKK,cAAL;AACD;;AAEDA,EAAAA,cAAc,GAAG;AACf,QAAI,KAAKC,aAAL,CAAmB,KAAKP,MAAxB,CAAJ,EAAqC;AACnC,YAAM,IAAIQ,KAAJ,CACJ,+EADI,CAAN;AAGD;AACF;;AAEDD,EAAAA,aAAa,CAACE,KAAD,EAAQ;AACnB,WAAOA,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACC,MAAN,KAAiB,CAAzC;AACD;;AAEDC,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKX,MAAL,CAAYY,OAAZ,CAAoB,KAAKT,MAAL,CAAYU,OAAZ,EAApB,IAA6C,CAAC,CAArD;AACD;;AAEDC,EAAAA,KAAK,CAACX,MAAD,EAAS;AACZ,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKD,MAAL,GAAcA,MAAd;AACD;;AAEDY,EAAAA,KAAK,CAACZ,MAAD,EAAS;AACZ,UAAMa,UAAU,GAAGb,MAAM,CAACc,QAAP,EAAnB;AACA,SAAKH,KAAL,CAAWX,MAAX;;AAEA,WAAO,KAAKQ,OAAL,MAAkB,KAAKP,KAAL,CAAWM,MAAX,IAAqB,KAAKR,GAAnD,EAAwD;AACtD,WAAKE,KAAL,IAAcD,MAAM,CAACU,OAAP,EAAd;;AACA,UAAIV,MAAM,CAACe,OAAP,EAAJ,EAAsB;AACpBf,QAAAA,MAAM,CAACgB,IAAP;AACD,OAFD,MAEO;AACL;AACD;AACF;;AAED,QAAI,KAAKf,KAAL,CAAWM,MAAX,GAAoB,KAAKT,GAA7B,EAAkC;AAChC,YAAM,IAAImB,mBAAJ,CACH,MAAK,KAAKrB,IAAK,0BAAyB,KAAKE,GAAI,qBAD9C,CAAN;AAGD;;AAED,UAAMoB,QAAQ,GAAGL,UAAU,GAAG,KAAKZ,KAAL,CAAWM,MAAxB,GAAiC,CAAlD;AACA,WAAO,IAAIY,kBAAJ,CAAc,KAAKvB,IAAnB,EAAyB,KAAKK,KAA9B,EAAqCY,UAArC,EAAiDK,QAAjD,CAAP;AACD;;AAEDE,EAAAA,KAAK,GAAG;AACN,WAAO,IAAI1B,KAAJ,CAAU,KAAKE,IAAf,EAAqB,KAAKC,MAA1B,EAAkC;AAAEC,MAAAA,GAAG,EAAE,KAAKA,GAAZ;AAAiBC,MAAAA,GAAG,EAAE,KAAKA;AAA3B,KAAlC,CAAP;AACD;;AA1DwB","sourcesContent":["import ParseError from \"../ParseError.js\";\nimport ValueNode from \"../ast/ValueNode.js\";\n\nexport default class OneOf {\n  constructor(name, values, { min, max } = {}) {\n    this.name = name;\n    this.values = values;\n    this.cursor = null;\n    this.match = \"\";\n    this.max = typeof max === \"number\" ? max : Infinity;\n    this.min = typeof min === \"number\" > 0 ? min : 0;\n\n    this.assertValidity();\n  }\n\n  assertValidity() {\n    if (this.isNullOrEmpty(this.values)) {\n      throw new Error(\n        \"Illegal Argument: Any needs to have a value that has a length greater than 0.\"\n      );\n    }\n  }\n\n  isNullOrEmpty(value) {\n    return value == null || value.length === 0;\n  }\n\n  isMatch() {\n    return this.values.indexOf(this.cursor.getChar()) > -1;\n  }\n\n  reset(cursor) {\n    this.match = \"\";\n    this.cursor = cursor;\n  }\n\n  parse(cursor) {\n    const startIndex = cursor.getIndex();\n    this.reset(cursor);\n\n    while (this.isMatch() && this.match.length <= this.max) {\n      this.match += cursor.getChar();\n      if (cursor.hasNext()) {\n        cursor.next();\n      } else {\n        break;\n      }\n    }\n\n    if (this.match.length < this.min) {\n      throw new ParseError(\n        `A '${this.name}' needs to be at least ${this.min} character(s) long.`\n      );\n    }\n\n    const endIndex = startIndex + this.match.length - 1;\n    return new ValueNode(this.name, this.match, startIndex, endIndex);\n  }\n\n  clone() {\n    return new OneOf(this.name, this.values, { min: this.min, max: this.max });\n  }\n}\n"],"file":"OneOf.js"}