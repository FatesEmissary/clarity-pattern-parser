{"version":3,"sources":["../../src/patterns/RecursivePattern.js"],"names":["RecursivePattern","name","isGettingPossibilities","_climb","parent","pattern","isMatch","cursor","getPattern","throwError","ParserError","index","clone","node","parse","hasUnresolvedError","addMatch","getCurrentMark","possibilities","getPossibilities","Pattern"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,gB;;;;;AACnB,4BAAYC,IAAZ,EAAkB;AAAA;;AAAA;;AAChB,0FAAM,WAAN,EAAmBA,IAAnB;AACA,UAAKC,sBAAL,GAA8B,KAA9B;AAFgB;AAGjB;;;;iCAEY;AAAA;;AACX,aAAO,KAAKC,MAAL,CAAY,KAAKC,MAAjB,EAAyB,UAAAC,OAAO,EAAI;AACzC,eAAOA,OAAO,CAACJ,IAAR,KAAiB,MAAI,CAACA,IAA7B;AACD,OAFM,CAAP;AAGD;;;2BAEMI,O,EAASC,O,EAAS;AACvB,UAAIA,OAAO,CAACD,OAAD,CAAX,EAAsB;AACpB,eAAOA,OAAP;AACD,OAFD,MAEO;AACL,YAAIA,OAAO,CAACD,MAAR,IAAkB,IAAtB,EAA4B;AAC1B,iBAAO,KAAKD,MAAL,CAAYE,OAAO,CAACD,MAApB,EAA4BE,OAA5B,CAAP;AACD;;AACD,eAAO,IAAP;AACD;AACF;;;0BAEKC,M,EAAQ;AACZ,UAAI,KAAKF,OAAL,IAAgB,IAApB,EAA0B;AACxB,YAAMA,OAAO,GAAG,KAAKG,UAAL,EAAhB;;AAEA,YAAIH,OAAO,IAAI,IAAf,EAAqB;AACnBE,UAAAA,MAAM,CAACE,UAAP,CACE,IAAIC,mBAAJ,4EACsE,KAAKT,IAD3E,OADF,EAIEM,MAAM,CAACI,KAJT,EAKE,IALF;AAOA,iBAAO,IAAP;AACD;;AAED,aAAKN,OAAL,GAAeA,OAAO,CAACO,KAAR,EAAf;AACA,aAAKP,OAAL,CAAaD,MAAb,GAAsB,IAAtB;AACD;;AAED,UAAMS,IAAI,GAAG,KAAKR,OAAL,CAAaS,KAAb,CAAmBP,MAAnB,CAAb;;AAEA,UAAI,CAACA,MAAM,CAACQ,kBAAP,EAAL,EAAkC;AAChCR,QAAAA,MAAM,CAACS,QAAP,CAAgB,IAAhB,EAAsBH,IAAtB;AACD;;AAED,aAAOA,IAAP;AACD;;;0BAEKZ,I,EAAM;AACV,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,QAAAA,IAAI,GAAG,KAAKA,IAAZ;AACD;;AACD,aAAO,IAAID,gBAAJ,CAAqBC,IAArB,CAAP;AACD;;;qCAEgB;AACf,aAAO,KAAKI,OAAL,CAAaY,cAAb,EAAP;AACD;;;uCAEkB;AACjB,UAAI,CAAC,KAAKf,sBAAV,EAAkC;AAChC,aAAKA,sBAAL,GAA8B,IAA9B;AACA,YAAMgB,aAAa,GAAG,KAAKV,UAAL,GAAkBW,gBAAlB,EAAtB;AACA,aAAKjB,sBAAL,GAA8B,KAA9B;AAEA,eAAOgB,aAAP;AACD,OAND,MAMO;AACL,eAAO,CAAC,KAAKjB,IAAN,CAAP;AACD;AACF;;;;EAxE2CmB,iB","sourcesContent":["import Pattern from \"./Pattern.js\";\nimport ParserError from \"./ParseError.js\";\n\nexport default class RecursivePattern extends Pattern {\n  constructor(name) {\n    super(\"recursive\", name);\n    this.isGettingPossibilities = false;\n  }\n\n  getPattern() {\n    return this._climb(this.parent, pattern => {\n      return pattern.name === this.name;\n    });\n  }\n\n  _climb(pattern, isMatch) {\n    if (isMatch(pattern)) {\n      return pattern;\n    } else {\n      if (pattern.parent != null) {\n        return this._climb(pattern.parent, isMatch);\n      }\n      return null;\n    }\n  }\n\n  parse(cursor) {\n    if (this.pattern == null) {\n      const pattern = this.getPattern();\n\n      if (pattern == null) {\n        cursor.throwError(\n          new ParserError(\n            `Couldn't find parent pattern to recursively parse, with the name ${this.name}.`\n          ),\n          cursor.index,\n          this\n        );\n        return null;\n      }\n\n      this.pattern = pattern.clone();\n      this.pattern.parent = this;\n    }\n\n    const node = this.pattern.parse(cursor);\n\n    if (!cursor.hasUnresolvedError()) {\n      cursor.addMatch(this, node);\n    }\n\n    return node;\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new RecursivePattern(name);\n  }\n\n  getCurrentMark() {\n    return this.pattern.getCurrentMark();\n  }\n\n  getPossibilities() {\n    if (!this.isGettingPossibilities) {\n      this.isGettingPossibilities = true;\n      const possibilities = this.getPattern().getPossibilities();\n      this.isGettingPossibilities = false;\n\n      return possibilities;\n    } else {\n      return [this.name];\n    }\n  }\n}\n"],"file":"RecursivePattern.js"}