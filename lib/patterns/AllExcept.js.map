{"version":3,"sources":["../../src/patterns/AllExcept.js"],"names":["ValueNode","Literal","ParseError","AllExcept","constructor","name","exceptions","literals","value","assertExceptions","sortExceptionsByLength","createAndSaveLiterals","Array","isArray","Error","forEach","exception","length","sort","a","b","map","parse","cursor","reset","parseValue","Valuethis","mark","x","literal","moveToMark","error","getChar","hasNext","next","index"],"mappings":"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","file":"AllExcept.js","sourcesContent":["import ValueNode from \"../ast/ValueNode.js\";\nimport Literal from \"./Literal.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class AllExcept {\n  constructor(name, exceptions) {\n    this.name = name;\n    this.exceptions = exceptions;\n    this.literals = [];\n    this.value = \"\";\n\n    this.assertExceptions();\n    this.sortExceptionsByLength();\n    this.createAndSaveLiterals();\n  }\n\n  assertExceptions() {\n    if (!Array.isArray(this.exceptions)) {\n      throw new Error(\n        \"Invalid Arguments: Expected exceptions to be an array of strings.\"\n      );\n    }\n\n    this.exceptions.forEach(exception => {\n      if (exception.length < 1) {\n        throw new Error(\n          \"Invalid Argument: Expected all exceptions to be at least one charater long.\"\n        );\n      }\n    });\n  }\n\n  sortExceptionsByLength() {\n    // Longest first\n    this.exceptions.sort((a, b) => {\n      return b.length - a.length;\n    });\n  }\n\n  createAndSaveLiterals() {\n    this.literals = this.exceptions.map(value => {\n      return new Literal(value, value);\n    });\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.parseValue();\n\n    return new Valuethis.value();\n  }\n\n  reset(cursor) {\n    this.cursor = cursor;\n    this.value = \"\";\n  }\n\n  parseValue() {\n    const mark = this.cursor.mark();\n\n    for (let x = 0; x < this.literals.length; x++) {\n      const literal = this.literals[x];\n\n      this.cursor.moveToMark(mark);\n\n      try {\n        literal.parse(this.cursor);\n\n        if (this.value.length > 0) {\n          this.cursor.moveToMark(mark);\n          return new ValueNode(this.name, this.value);\n        } else {\n          throw new ParseError(\n            `Did not expect '${this.exceptions[x]}' within a(n) ${this.name}.`\n          );\n        }\n      } catch (error) {\n        // Good\n      }\n    }\n\n    this.value += this.cursor.getChar();\n\n    if (this.cursor.hasNext()) {\n      this.cursor.next();\n      this.parseValue();\n    } else {\n      if (this.value.length > 0) {\n        return new ValueNode(this.name, this.value);\n      } else {\n        throw new ParseError(\n          \"Did not match any characters.\",\n          this.cursor.index\n        );\n      }\n    }\n  }\n}\n"]}