{"version":3,"sources":["../../../src/patterns/value/RepeatValue.js"],"names":["RepeatValue","name","pattern","divider","_pattern","children","_divider","_assertArguments","_reset","OptionalValue","Error","cursor","parseError","mark","nodes","ParseError","_tryPattern","node","parse","push","endIndex","lastIndex","_processMatch","next","error","moveToMark","length","message","index","value","map","join","ValueNode","startIndex","setIndex","ValuePattern"],"mappings":"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","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\nimport OptionalValue from \"./OptionalValue.js\";\n\nexport default class RepeatValue extends ValuePattern {\n  constructor(name, pattern, divider) {\n    super(name, divider != null ? [pattern, divider] : [pattern]);\n\n    this._pattern = this.children[0];\n    this._divider = this.children[1];\n\n    this._assertArguments();\n    this._reset();\n  }\n\n  _assertArguments() {\n    if (this._pattern instanceof OptionalValue) {\n      throw new Error(\n        \"Invalid Arguments: The pattern cannot be a optional pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor, parseError) {\n    this.cursor = null;\n    this.mark = null;\n    this.nodes = [];\n    this.parseError = parseError;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n\n    if (parseError == null) {\n      this.parseError = new ParseError();\n    }\n  }\n\n  parse(cursor, parseError) {\n    this._reset(cursor, parseError);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      let mark = this.cursor.mark();\n\n      try {\n        const node = this._pattern.parse(this.cursor, this.parseError);\n        this.nodes.push(node);\n\n        if (node.endIndex === this.cursor.lastIndex()) {\n          this._processMatch();\n          break;\n        }\n\n        mark = this.cursor.mark();\n\n        this.cursor.next();\n\n        if (this._divider != null) {\n          const mark = this.cursor.mark();\n          try {\n            this.nodes.push(this._divider.parse(this.cursor, this.parseError));\n            this.cursor.next();\n          } catch (error) {\n            this.cursor.moveToMark(mark);\n            this._processMatch();\n            break;\n          }\n        }\n      } catch (error) {\n        this._processMatch();\n        break;\n      }\n    }\n  }\n\n  _processMatch() {\n    if (this.nodes.length === 0) {\n      this.parseError.message= `Did not find a repeating match of ${this.name}.`;\n      this.parseError.index = this.mark.index;\n      this.parseError.pattern = this;\n\n      throw this.parseError;\n    } else {\n      const value = this.nodes.map(node => node.value).join(\"\");\n\n      this.node = new ValueNode(\n        this.name,\n        value,\n        this.nodes[0].startIndex,\n        this.nodes[this.nodes.length - 1].endIndex\n      );\n\n      this.cursor.setIndex(this.node.endIndex);\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new RepeatValue(name, this._pattern, this._divider);\n  }\n\n  getCurrentMark() {\n    return this.mark;\n  }\n}\n"],"file":"RepeatValue.js"}