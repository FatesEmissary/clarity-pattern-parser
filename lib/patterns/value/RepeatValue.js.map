{"version":3,"sources":["../../../src/patterns/value/RepeatValue.js"],"names":["RepeatValue","name","pattern","_assertArguments","_reset","children","OptionalValue","Error","cursor","mark","nodes","_tryPattern","node","parse","push","endIndex","lastIndex","_processMatch","error","moveToMark","length","ParseError","index","value","map","join","ValueNode","startIndex","ValuePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,W;;;;;AACnB,uBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAAA;;AACzB,qFAAMD,IAAN,EAAY,CAACC,OAAD,CAAZ;;AAEA,UAAKC,gBAAL;;AACA,UAAKC,MAAL;;AAJyB;AAK1B;;;;uCAEkB;AACjB,UAAI,KAAKC,QAAL,CAAc,CAAd,aAA4BC,sBAAhC,EAA+C;AAC7C,cAAM,IAAIC,KAAJ,CACJ,8DADI,CAAN;AAGD;AACF;;;2BAEMC,M,EAAQ;AACb,WAAKA,MAAL,GAAc,IAAd;AACA,WAAKC,IAAL,GAAY,IAAZ;AACA,WAAKC,KAAL,GAAa,EAAb;;AAEA,UAAIF,MAAM,IAAI,IAAd,EAAoB;AAClB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKC,IAAL,GAAY,KAAKD,MAAL,CAAYC,IAAZ,EAAZ;AACD;AACF;;;0BAEKD,M,EAAQ;AACZ,WAAKJ,MAAL,CAAYI,MAAZ;;AACA,WAAKG,WAAL;;AAEA,aAAO,KAAKC,IAAZ;AACD;;;kCAEa;AACZ,aAAO,IAAP,EAAa;AACX,YAAMH,IAAI,GAAG,KAAKD,MAAL,CAAYC,IAAZ,EAAb;;AAEA,YAAI;AACF,cAAMG,IAAI,GAAG,KAAKP,QAAL,CAAc,CAAd,EAAiBQ,KAAjB,CAAuB,KAAKL,MAA5B,CAAb;AACA,eAAKE,KAAL,CAAWI,IAAX,CAAgBF,IAAhB;;AAEA,cAAIA,IAAI,CAACG,QAAL,KAAkB,KAAKP,MAAL,CAAYQ,SAAZ,EAAtB,EAA8C;AAC5C,iBAAKC,aAAL;;AACA;AACD;AACF,SARD,CAQE,OAAOC,KAAP,EAAc;AACd,eAAKD,aAAL;;AACA,eAAKT,MAAL,CAAYW,UAAZ,CAAuBV,IAAvB;AACA;AACD;AACF;AACF;;;oCAEe;AACd,UAAI,KAAKC,KAAL,CAAWU,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,cAAM,IAAIC,mBAAJ,6CACiC,KAAKhB,QAAL,CAAc,CAAd,EAAiBJ,IADlD,QAEJ,KAAKQ,IAAL,CAAUa,KAFN,EAGJ,IAHI,CAAN;AAKD,OAND,MAMO;AACL,YAAMC,KAAK,GAAG,KAAKb,KAAL,CAAWc,GAAX,CAAe,UAAAZ,IAAI;AAAA,iBAAIA,IAAI,CAACW,KAAT;AAAA,SAAnB,EAAmCE,IAAnC,CAAwC,EAAxC,CAAd;AAEA,aAAKb,IAAL,GAAY,IAAIc,kBAAJ,CACV,KAAKzB,IADK,EAEVsB,KAFU,EAGV,KAAKb,KAAL,CAAW,CAAX,EAAciB,UAHJ,EAIV,KAAKjB,KAAL,CAAW,KAAKA,KAAL,CAAWU,MAAX,GAAoB,CAA/B,EAAkCL,QAJxB,CAAZ;AAMD;AACF;;;4BAEO;AACN,aAAO,IAAIf,WAAJ,CAAgB,KAAKC,IAArB,EAA2B,KAAKI,QAAL,CAAc,CAAd,CAA3B,CAAP;AACD;;;;EA3EsCuB,sB","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode\";\nimport ParseError from \"../ParseError.js\";\nimport OptionalValue from \"./OptionalValue.js\";\n\nexport default class RepeatValue extends ValuePattern {\n  constructor(name, pattern) {\n    super(name, [pattern]);\n\n    this._assertArguments();\n    this._reset();\n  }\n\n  _assertArguments() {\n    if (this.children[0] instanceof OptionalValue) {\n      throw new Error(\n        \"Invalid Arguments: The pattern cannot be a optional pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor) {\n    this.cursor = null;\n    this.mark = null;\n    this.nodes = [];\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      const mark = this.cursor.mark();\n\n      try {\n        const node = this.children[0].parse(this.cursor);\n        this.nodes.push(node);\n\n        if (node.endIndex === this.cursor.lastIndex()){\n          this._processMatch();\n          break;\n        }\n      } catch (error) {\n        this._processMatch();\n        this.cursor.moveToMark(mark);\n        break;\n      }\n    }\n  }\n\n  _processMatch() {\n    if (this.nodes.length === 0) {\n      throw new ParseError(\n        `Did not find a repeating match of ${this.children[0].name}.`,\n        this.mark.index,\n        this\n      );\n    } else {\n      const value = this.nodes.map(node => node.value).join(\"\");\n\n      this.node = new ValueNode(\n        this.name,\n        value,\n        this.nodes[0].startIndex,\n        this.nodes[this.nodes.length - 1].endIndex\n      );\n    }\n  }\n\n  clone() {\n    return new RepeatValue(this.name, this.children[0]);\n  }\n}\n"],"file":"RepeatValue.js"}