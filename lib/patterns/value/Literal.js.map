{"version":3,"sources":["../../../src/patterns/value/Literal.js"],"names":["Literal","name","literal","_assertArguments","Error","length","cursor","parseError","_reset","_assertCursor","_tryPattern","node","mark","substring","string","index","ParseError","Cursor","_processMatch","_processError","message","charAt","getChar","getIndex","pattern","ValueNode","setIndex","endIndex","ValuePattern"],"mappings":"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","sourcesContent":["import ParseError from \"../ParseError.js\";\nimport Cursor from \"../../Cursor.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ValuePattern from \"./ValuePattern.js\";\n\nexport default class Literal extends ValuePattern {\n  constructor(name, literal) {\n    super(name);\n    this.literal = literal;\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (typeof this.literal !== \"string\") {\n      throw new Error(\n        \"Invalid Arguments: The literal argument needs to be a string of characters.\"\n      );\n    }\n\n    if (this.literal.length < 1) {\n      throw new Error(\n        \"Invalid Arguments: The literalString argument needs to be at least one character long.\"\n      );\n    }\n  }\n\n  parse(cursor, parseError) {\n    this._reset(cursor, parseError);\n    this._assertCursor();\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _reset(cursor, parseError) {\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n      this.substring = this.cursor.string.substring(\n        this.mark.index,\n        this.mark.index + this.literal.length\n      );\n    } else {\n      this.cursor = null;\n      this.mark = null;\n      this.substring = null;\n    }\n\n    this.parseError = parseError;\n    this.node = null;\n\n    if (parseError == null){\n      this.parseError = new ParseError();\n    }\n  }\n\n  _assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  _tryPattern() {\n    if (this.substring === this.literal) {\n      this._processMatch();\n    } else {\n      this._processError();\n    }\n  }\n\n  _processError() {\n    const message = `ParseError: Expected '${this.literal.charAt(\n      this.index\n    )}' but found '${this.cursor.getChar()}' while parsing for '${this.name}'.`;\n\n    this.parseError.message = message;\n    this.parseError.index = this.cursor.getIndex();\n    this.parseError.pattern = this;\n\n    throw this.parseError;\n  }\n\n  _processMatch() {\n    this.node = new ValueNode(\n      this.name,\n      this.substring,\n      this.mark.index,\n      this.mark.index + this.literal.length - 1\n    );\n\n    this.cursor.setIndex(this.node.endIndex);\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new Literal(name, this.literal);\n  }\n\n  getCurrentMark(){\n    return this.mark;\n  }\n}\n"],"file":"Literal.js"}