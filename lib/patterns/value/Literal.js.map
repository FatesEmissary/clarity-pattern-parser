{"version":3,"sources":["../../../src/patterns/value/Literal.js"],"names":["Literal","name","literalString","literal","reset","assertArguments","Error","length","cursor","assertCursor","tryPattern","node","mark","index","match","Cursor","doesCharacterMatch","processCharacterMatch","processError","charAt","getChar","saveMatch","isComplete","ValueNode","getIndex","incrementIndex","hasNext","next","message","ParseError","ValuePattern"],"mappings":"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","sourcesContent":["import ParseError from \"../ParseError.js\";\nimport Cursor from \"../../Cursor.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ValuePattern from \"./ValuePattern.js\";\n\nexport default class Literal extends ValuePattern {\n  constructor(name, literalString) {\n    super();\n\n    this.name = name;\n    this.literal = literalString;\n\n    this.reset(null);\n    this.assertArguments();\n  }\n\n  assertArguments() {\n    if (typeof this.name !== \"string\") {\n      throw new Error(\"Invalid Arguments: The name needs to be a string.\");\n    }\n\n    if (typeof this.literal !== \"string\") {\n      throw new Error(\n        \"Invalid Arguments: The literalString argument needs to be a string of characters.\"\n      );\n    }\n\n    if (this.literal.length < 1) {\n      throw new Error(\n        \"Invalid Arguments: The literalString argument needs to be at least one character long.\"\n      );\n    }\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.assertCursor();\n    this.tryPattern();\n\n    return this.node;\n  }\n\n  reset(cursor) {\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    } else {\n      this.cursor = null;\n      this.mark = null;\n    }\n\n    this.index = 0;\n    this.match = \"\";\n    this.node = null;\n  }\n\n  assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  tryPattern() {\n    if (this.doesCharacterMatch()) {\n      this.processCharacterMatch();\n    } else {\n      this.processError();\n    }\n  }\n\n  doesCharacterMatch() {\n    return this.literal.charAt(this.index) === this.cursor.getChar();\n  }\n\n  processCharacterMatch() {\n    this.saveMatch();\n\n    if (this.isComplete()) {\n      this.node = new ValueNode(\n        this.name,\n        this.literal,\n        this.mark.index,\n        this.cursor.getIndex()\n      );\n\n      this.incrementIndex();\n    } else {\n      this.incrementIndex();\n      this.tryPattern();\n    }\n  }\n\n  saveMatch() {\n    this.match += this.cursor.getChar();\n  }\n\n  isComplete() {\n    return this.match === this.literal;\n  }\n\n  incrementIndex() {\n    if (this.cursor.hasNext()) {\n      this.cursor.next();\n      this.index++;\n    }\n  }\n\n  processError() {\n    const message = `ParseError: Expected '${this.literal.charAt(\n      this.index\n    )}' but found '${this.cursor.getChar()}' while parsing for '${this.name}'.`;\n\n    throw new ParseError(message, this.cursor.getIndex(), this);\n  }\n\n  clone() {\n    return new Literal(this.name, this.literal);\n  }\n\n  getValue() {\n    return this.literal;\n  }\n}\n"],"file":"Literal.js"}