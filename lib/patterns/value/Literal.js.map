{"version":3,"sources":["../../../src/patterns/value/Literal.js"],"names":["Literal","name","literal","_reset","_assertArguments","Error","length","cursor","_assertCursor","_tryPattern","node","mark","index","match","Cursor","_doesCharacterMatch","_processCharacterMatch","_processError","charAt","getChar","_saveMatch","_isComplete","ValueNode","getIndex","_incrementIndex","hasNext","next","message","ParseError","ValuePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,O;;;;;AACnB,mBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAAA;;AACzB,iFAAMD,IAAN;AACA,UAAKC,OAAL,GAAeA,OAAf;;AAEA,UAAKC,MAAL,CAAY,IAAZ;;AACA,UAAKC,gBAAL;;AALyB;AAM1B;;;;uCAEkB;AACjB,UAAI,OAAO,KAAKF,OAAZ,KAAwB,QAA5B,EAAsC;AACpC,cAAM,IAAIG,KAAJ,CACJ,6EADI,CAAN;AAGD;;AAED,UAAI,KAAKH,OAAL,CAAaI,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,cAAM,IAAID,KAAJ,CACJ,wFADI,CAAN;AAGD;AACF;;;0BAEKE,M,EAAQ;AACZ,WAAKJ,MAAL,CAAYI,MAAZ;;AACA,WAAKC,aAAL;;AACA,WAAKC,WAAL;;AAEA,aAAO,KAAKC,IAAZ;AACD;;;2BAEMH,M,EAAQ;AACb,UAAIA,MAAM,IAAI,IAAd,EAAoB;AAClB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKI,IAAL,GAAY,KAAKJ,MAAL,CAAYI,IAAZ,EAAZ;AACD,OAHD,MAGO;AACL,aAAKJ,MAAL,GAAc,IAAd;AACA,aAAKI,IAAL,GAAY,IAAZ;AACD;;AAED,WAAKC,KAAL,GAAa,CAAb;AACA,WAAKC,KAAL,GAAa,EAAb;AACA,WAAKH,IAAL,GAAY,IAAZ;AACD;;;oCAEe;AACd,UAAI,EAAE,KAAKH,MAAL,YAAuBO,eAAzB,CAAJ,EAAsC;AACpC,cAAM,IAAIT,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;;kCAEa;AACZ,UAAI,KAAKU,mBAAL,EAAJ,EAAgC;AAC9B,aAAKC,sBAAL;AACD,OAFD,MAEO;AACL,aAAKC,aAAL;AACD;AACF;;;0CAEqB;AACpB,aAAO,KAAKf,OAAL,CAAagB,MAAb,CAAoB,KAAKN,KAAzB,MAAoC,KAAKL,MAAL,CAAYY,OAAZ,EAA3C;AACD;;;6CAEwB;AACvB,WAAKC,UAAL;;AAEA,UAAI,KAAKC,WAAL,EAAJ,EAAwB;AACtB,aAAKX,IAAL,GAAY,IAAIY,kBAAJ,CACV,KAAKrB,IADK,EAEV,KAAKC,OAFK,EAGV,KAAKS,IAAL,CAAUC,KAHA,EAIV,KAAKL,MAAL,CAAYgB,QAAZ,EAJU,CAAZ;;AAOA,aAAKC,eAAL;AACD,OATD,MASO;AACL,aAAKA,eAAL;;AACA,aAAKf,WAAL;AACD;AACF;;;iCAEY;AACX,WAAKI,KAAL,IAAc,KAAKN,MAAL,CAAYY,OAAZ,EAAd;AACD;;;kCAEa;AACZ,aAAO,KAAKN,KAAL,KAAe,KAAKX,OAA3B;AACD;;;sCAEiB;AAChB,UAAI,KAAKK,MAAL,CAAYkB,OAAZ,EAAJ,EAA2B;AACzB,aAAKlB,MAAL,CAAYmB,IAAZ;AACA,aAAKd,KAAL;AACD;AACF;;;oCAEe;AACd,UAAMe,OAAO,mCAA4B,KAAKzB,OAAL,CAAagB,MAAb,CACvC,KAAKN,KADkC,CAA5B,0BAEI,KAAKL,MAAL,CAAYY,OAAZ,EAFJ,kCAEiD,KAAKlB,IAFtD,OAAb;AAIA,YAAM,IAAI2B,mBAAJ,CAAeD,OAAf,EAAwB,KAAKpB,MAAL,CAAYgB,QAAZ,EAAxB,EAAgD,IAAhD,CAAN;AACD;;;4BAEO;AACN,aAAO,IAAIvB,OAAJ,CAAY,KAAKC,IAAjB,EAAuB,KAAKC,OAA5B,CAAP;AACD;;;;EA1GkC2B,sB","sourcesContent":["import ParseError from \"../ParseError.js\";\nimport Cursor from \"../../Cursor.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ValuePattern from \"./ValuePattern.js\";\n\nexport default class Literal extends ValuePattern {\n  constructor(name, literal) {\n    super(name);\n    this.literal = literal;\n\n    this._reset(null);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (typeof this.literal !== \"string\") {\n      throw new Error(\n        \"Invalid Arguments: The literal argument needs to be a string of characters.\"\n      );\n    }\n\n    if (this.literal.length < 1) {\n      throw new Error(\n        \"Invalid Arguments: The literalString argument needs to be at least one character long.\"\n      );\n    }\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._assertCursor();\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _reset(cursor) {\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    } else {\n      this.cursor = null;\n      this.mark = null;\n    }\n\n    this.index = 0;\n    this.match = \"\";\n    this.node = null;\n  }\n\n  _assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  _tryPattern() {\n    if (this._doesCharacterMatch()) {\n      this._processCharacterMatch();\n    } else {\n      this._processError();\n    }\n  }\n\n  _doesCharacterMatch() {\n    return this.literal.charAt(this.index) === this.cursor.getChar();\n  }\n\n  _processCharacterMatch() {\n    this._saveMatch();\n\n    if (this._isComplete()) {\n      this.node = new ValueNode(\n        this.name,\n        this.literal,\n        this.mark.index,\n        this.cursor.getIndex()\n      );\n\n      this._incrementIndex();\n    } else {\n      this._incrementIndex();\n      this._tryPattern();\n    }\n  }\n\n  _saveMatch() {\n    this.match += this.cursor.getChar();\n  }\n\n  _isComplete() {\n    return this.match === this.literal;\n  }\n\n  _incrementIndex() {\n    if (this.cursor.hasNext()) {\n      this.cursor.next();\n      this.index++;\n    }\n  }\n\n  _processError() {\n    const message = `ParseError: Expected '${this.literal.charAt(\n      this.index\n    )}' but found '${this.cursor.getChar()}' while parsing for '${this.name}'.`;\n\n    throw new ParseError(message, this.cursor.getIndex(), this);\n  }\n\n  clone() {\n    return new Literal(this.name, this.literal);\n  }\n\n}\n"],"file":"Literal.js"}