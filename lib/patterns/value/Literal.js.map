{"version":3,"sources":["../../../src/patterns/value/Literal.js"],"names":["Literal","name","literal","_assertArguments","Error","length","cursor","_reset","_tryPattern","node","mark","substring","string","_processMatch","_processError","message","parseError","ParseError","getIndex","throwError","ValueNode","index","endIndex","addMatch","ValuePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,O;;;;;AACnB,mBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAAA;;AACzB,iFAAM,SAAN,EAAiBD,IAAjB;AACA,UAAKC,OAAL,GAAeA,OAAf;;AACA,UAAKC,gBAAL;;AAHyB;AAI1B;;;;uCAEkB;AACjB,UAAI,OAAO,KAAKD,OAAZ,KAAwB,QAA5B,EAAsC;AACpC,cAAM,IAAIE,KAAJ,CACJ,6EADI,CAAN;AAGD;;AAED,UAAI,KAAKF,OAAL,CAAaG,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,cAAM,IAAID,KAAJ,CACJ,wFADI,CAAN;AAGD;AACF;;;0BAEKE,M,EAAQ;AACZ,WAAKC,MAAL,CAAYD,MAAZ;;AACA,WAAKE,WAAL;;AAEA,aAAO,KAAKC,IAAZ;AACD;;;2BAEMH,M,EAAQ;AACb,WAAKA,MAAL,GAAcA,MAAd;AACA,WAAKI,IAAL,GAAY,KAAKJ,MAAL,CAAYI,IAAZ,EAAZ;AACA,WAAKC,SAAL,GAAiB,KAAKL,MAAL,CAAYM,MAAZ,CAAmBD,SAAnB,CACf,KAAKD,IADU,EAEf,KAAKA,IAAL,GAAY,KAAKR,OAAL,CAAaG,MAFV,CAAjB;AAIA,WAAKI,IAAL,GAAY,IAAZ;AACD;;;kCAEa;AACZ,UAAI,KAAKE,SAAL,KAAmB,KAAKT,OAA5B,EAAqC;AACnC,aAAKW,aAAL;AACD,OAFD,MAEO;AACL,aAAKC,aAAL;AACD;AACF;;;oCAEe;AACd,UAAMC,OAAO,mCAA4B,KAAKb,OAAjC,0BAAwD,KAAKS,SAA7D,OAAb;AAEA,UAAMK,UAAU,GAAG,IAAIC,mBAAJ,CAAeF,OAAf,EAAwB,KAAKT,MAAL,CAAYY,QAAZ,EAAxB,EAAgD,IAAhD,CAAnB;AACA,WAAKZ,MAAL,CAAYa,UAAZ,CAAuBH,UAAvB;AACD;;;oCAEe;AACd,WAAKP,IAAL,GAAY,IAAIW,kBAAJ,CACV,SADU,EAEV,KAAKnB,IAFK,EAGV,KAAKU,SAHK,EAIV,KAAKD,IAJK,EAKV,KAAKA,IAAL,GAAY,KAAKR,OAAL,CAAaG,MAAzB,GAAkC,CALxB,CAAZ;AAQA,WAAKC,MAAL,CAAYe,KAAZ,GAAoB,KAAKZ,IAAL,CAAUa,QAA9B;AACA,WAAKhB,MAAL,CAAYiB,QAAZ,CAAqB,IAArB,EAA2B,KAAKd,IAAhC;AACD;;;0BAEKR,I,EAAM;AACV,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,QAAAA,IAAI,GAAG,KAAKA,IAAZ;AACD;;AACD,aAAO,IAAID,OAAJ,CAAYC,IAAZ,EAAkB,KAAKC,OAAvB,CAAP;AACD;;;uCAEkB;AACjB,aAAO,CAAC,KAAKA,OAAN,CAAP;AACD;;;;EA3EkCsB,sB","sourcesContent":["import ParseError from \"../ParseError.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ValuePattern from \"./ValuePattern.js\";\n\nexport default class Literal extends ValuePattern {\n  constructor(name, literal) {\n    super(\"literal\", name);\n    this.literal = literal;\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (typeof this.literal !== \"string\") {\n      throw new Error(\n        \"Invalid Arguments: The literal argument needs to be a string of characters.\"\n      );\n    }\n\n    if (this.literal.length < 1) {\n      throw new Error(\n        \"Invalid Arguments: The literalString argument needs to be at least one character long.\"\n      );\n    }\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _reset(cursor) {\n    this.cursor = cursor;\n    this.mark = this.cursor.mark();\n    this.substring = this.cursor.string.substring(\n      this.mark,\n      this.mark + this.literal.length\n    );\n    this.node = null;\n  }\n\n  _tryPattern() {\n    if (this.substring === this.literal) {\n      this._processMatch();\n    } else {\n      this._processError();\n    }\n  }\n\n  _processError() {\n    const message = `ParseError: Expected '${this.literal}' but found '${this.substring}'.`;\n\n    const parseError = new ParseError(message, this.cursor.getIndex(), this);\n    this.cursor.throwError(parseError);\n  }\n\n  _processMatch() {\n    this.node = new ValueNode(\n      \"literal\",\n      this.name,\n      this.substring,\n      this.mark,\n      this.mark + this.literal.length - 1\n    );\n\n    this.cursor.index = this.node.endIndex;\n    this.cursor.addMatch(this, this.node);\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new Literal(name, this.literal);\n  }\n\n  getPossibilities() {\n    return [this.literal];\n  }\n}\n"],"file":"Literal.js"}