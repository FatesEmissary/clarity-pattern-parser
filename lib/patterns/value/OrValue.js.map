{"version":3,"sources":["../../../src/patterns/value/OrValue.js"],"names":["OrValue","name","patterns","_assertArguments","_children","length","Error","hasOptionalChildren","some","pattern","OptionalValue","cursor","index","errors","node","mark","_reset","_tryPattern","parse","parseError","hasUnresolvedError","resolveError","moveToMark","ValueNode","value","startIndex","endIndex","addMatch","rootPattern","Pattern","children","map","child","getPossibilities","reduce","acc","concat","ValuePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,O;;;;;AACnB,mBAAYC,IAAZ,EAAkBC,QAAlB,EAA4B;AAAA;;AAAA;;AAC1B,iFAAM,UAAN,EAAkBD,IAAlB,EAAwBC,QAAxB;;AACA,UAAKC,gBAAL;;AAF0B;AAG3B;;;;uCAEkB;AACjB,UAAI,KAAKC,SAAL,CAAeC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,cAAM,IAAIC,KAAJ,CACJ,sEADI,CAAN;AAGD;;AAED,UAAMC,mBAAmB,GAAG,KAAKH,SAAL,CAAeI,IAAf,CAC1B,UAAAC,OAAO;AAAA,eAAIA,OAAO,YAAYC,sBAAvB;AAAA,OADmB,CAA5B;;AAIA,UAAIH,mBAAJ,EAAyB;AACvB,cAAM,IAAID,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;;2BAEMK,M,EAAQ;AACb,WAAKC,KAAL,GAAa,CAAb;AACA,WAAKC,MAAL,GAAc,EAAd;AACA,WAAKC,IAAL,GAAY,IAAZ;AACA,WAAKH,MAAL,GAAcA,MAAd;AACA,WAAKI,IAAL,GAAYJ,MAAM,CAACI,IAAP,EAAZ;AACD;;;0BAEKJ,M,EAAQ;AACZ,WAAKK,MAAL,CAAYL,MAAZ;;AACA,WAAKM,WAAL;;AAEA,aAAO,KAAKH,IAAZ;AACD;;;kCAEa;AACZ,aAAO,IAAP,EAAa;AACX,YAAML,OAAO,GAAG,KAAKL,SAAL,CAAe,KAAKQ,KAApB,CAAhB;AACA,YAAME,IAAI,GAAGL,OAAO,CAACS,KAAR,CAAc,KAAKP,MAAnB,EAA2B,KAAKQ,UAAhC,CAAb;;AAEA,YAAI,KAAKR,MAAL,CAAYS,kBAAZ,EAAJ,EAAsC;AACpC,cAAI,KAAKR,KAAL,GAAa,CAAb,GAAiB,KAAKR,SAAL,CAAeC,MAApC,EAA4C;AAC1C,iBAAKM,MAAL,CAAYU,YAAZ;AACA,iBAAKT,KAAL;AACA,iBAAKD,MAAL,CAAYW,UAAZ,CAAuB,KAAKP,IAA5B;AACD,WAJD,MAIO;AACL,iBAAKD,IAAL,GAAY,IAAZ;AACA;AACD;AACF,SATD,MASO;AACL,eAAKA,IAAL,GAAY,IAAIS,kBAAJ,CACV,UADU,EAEV,KAAKtB,IAFK,EAGVa,IAAI,CAACU,KAHK,EAIVV,IAAI,CAACW,UAJK,EAKVX,IAAI,CAACY,QALK,CAAZ;AAQA,eAAKf,MAAL,CAAYC,KAAZ,GAAoB,KAAKE,IAAL,CAAUY,QAA9B;AACA,eAAKf,MAAL,CAAYgB,QAAZ,CAAqB,IAArB,EAA2B,KAAKb,IAAhC;AAEA;AACD;AACF;AACF;;;0BAEKb,I,EAAM;AACV,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,QAAAA,IAAI,GAAG,KAAKA,IAAZ;AACD;;AACD,aAAO,IAAID,OAAJ,CAAYC,IAAZ,EAAkB,KAAKG,SAAvB,CAAP;AACD;;;qCAEgBwB,W,EAAa;AAC5B,UAAIA,WAAW,IAAI,IAAf,IAAuB,EAAEA,WAAW,YAAYC,gBAAzB,CAA3B,EAA8D;AAC5DD,QAAAA,WAAW,GAAG,IAAd;AACD;;AAED,aAAO,KAAKE,QAAL,CACJC,GADI,CACA,UAAAC,KAAK,EAAI;AACZ,eAAOA,KAAK,CAACC,gBAAN,CAAuBL,WAAvB,CAAP;AACD,OAHI,EAIJM,MAJI,CAIG,UAACC,GAAD,EAAMX,KAAN,EAAgB;AACtB,eAAOW,GAAG,CAACC,MAAJ,CAAWZ,KAAX,CAAP;AACD,OANI,EAMF,EANE,CAAP;AAOD;;;;EAvFkCa,sB","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport OptionalValue from \"./OptionalValue.js\";\nimport Pattern from \"../Pattern.js\";\n\nexport default class OrValue extends ValuePattern {\n  constructor(name, patterns) {\n    super(\"or-value\", name, patterns);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._children.length < 2) {\n      throw new Error(\n        \"Invalid Argument: OrValue needs to have more than one value pattern.\"\n      );\n    }\n\n    const hasOptionalChildren = this._children.some(\n      pattern => pattern instanceof OptionalValue\n    );\n\n    if (hasOptionalChildren) {\n      throw new Error(\"OrValues cannot have optional values.\");\n    }\n  }\n\n  _reset(cursor) {\n    this.index = 0;\n    this.errors = [];\n    this.node = null;\n    this.cursor = cursor;\n    this.mark = cursor.mark();\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      const pattern = this._children[this.index];\n      const node = pattern.parse(this.cursor, this.parseError);\n\n      if (this.cursor.hasUnresolvedError()) {\n        if (this.index + 1 < this._children.length) {\n          this.cursor.resolveError();\n          this.index++;\n          this.cursor.moveToMark(this.mark);\n        } else {\n          this.node = null;\n          break;\n        }\n      } else {\n        this.node = new ValueNode(\n          \"or-value\",\n          this.name,\n          node.value,\n          node.startIndex,\n          node.endIndex\n        );\n\n        this.cursor.index = this.node.endIndex;\n        this.cursor.addMatch(this, this.node);\n\n        break;\n      }\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new OrValue(name, this._children);\n  }\n\n  getPossibilities(rootPattern) {\n    if (rootPattern == null || !(rootPattern instanceof Pattern)) {\n      rootPattern = this;\n    }\n\n    return this.children\n      .map(child => {\n        return child.getPossibilities(rootPattern);\n      })\n      .reduce((acc, value) => {\n        return acc.concat(value);\n      }, []);\n  }\n}\n"],"file":"OrValue.js"}