{"version":3,"sources":["../../../src/patterns/value/AnyOfThese.js"],"names":["AnyOfThese","ValuePattern","constructor","name","characters","reset","assertArguments","Error","length","getName","parse","cursor","assertCursor","tryParse","node","Cursor","mark","isMatch","value","getChar","index","ValueNode","incrementCursor","processError","indexOf","message","ParseError","getIndex","hasNext","next","clone","getValue"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;AAEe,MAAMA,UAAN,SAAyBC,qBAAzB,CAAsC;AACnDC,EAAAA,WAAW,CAACC,IAAD,EAAOC,UAAP,EAAmB;AAC5B;AACA,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AAEA,SAAKC,KAAL;AACA,SAAKC,eAAL;AACD;;AAEDA,EAAAA,eAAe,GAAG;AAChB,QAAI,OAAO,KAAKH,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,YAAM,IAAII,KAAJ,CAAU,mDAAV,CAAN;AACD;;AAED,QAAI,OAAO,KAAKH,UAAZ,KAA2B,QAA/B,EAAyC;AACvC,YAAM,IAAIG,KAAJ,CACJ,gFADI,CAAN;AAGD;;AAED,QAAI,KAAKH,UAAL,CAAgBI,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,YAAM,IAAID,KAAJ,CACJ,qFADI,CAAN;AAGD;AACF;;AAEDE,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKN,IAAZ;AACD;;AAEDO,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,SAAKN,KAAL,CAAWM,MAAX;AACA,SAAKC,YAAL;AACA,SAAKC,QAAL;AACA,WAAO,KAAKC,IAAZ;AACD;;AAEDF,EAAAA,YAAY,GAAG;AACb,QAAI,EAAE,KAAKD,MAAL,YAAuBI,eAAzB,CAAJ,EAAsC;AACpC,YAAM,IAAIR,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;AAEDF,EAAAA,KAAK,CAACM,MAAD,EAAS;AACZ,QAAIA,MAAM,IAAI,IAAd,EAAoB;AAClB,WAAKA,MAAL,GAAc,IAAd;AACA,WAAKK,IAAL,GAAY,IAAZ;AACD,KAHD,MAGO;AACL,WAAKL,MAAL,GAAcA,MAAd;AACA,WAAKK,IAAL,GAAY,KAAKL,MAAL,CAAYK,IAAZ,EAAZ;AACD;;AAED,SAAKF,IAAL,GAAY,IAAZ;AACD;;AAEDD,EAAAA,QAAQ,GAAG;AACT,QAAI,KAAKI,OAAL,EAAJ,EAAoB;AAClB,YAAMC,KAAK,GAAG,KAAKP,MAAL,CAAYQ,OAAZ,EAAd;AACA,YAAMC,KAAK,GAAG,KAAKJ,IAAL,CAAUI,KAAxB;AAEA,WAAKN,IAAL,GAAY,IAAIO,kBAAJ,CAAc,KAAKlB,IAAnB,EAAyBe,KAAzB,EAAgCE,KAAhC,EAAuCA,KAAvC,CAAZ;AACA,WAAKE,eAAL;AACD,KAND,MAMO;AACL,WAAKC,YAAL;AACD;AACF;;AAEDN,EAAAA,OAAO,GAAG;AACR,WAAO,KAAKb,UAAL,CAAgBoB,OAAhB,CAAwB,KAAKb,MAAL,CAAYQ,OAAZ,EAAxB,IAAiD,CAAC,CAAzD;AACD;;AAEDI,EAAAA,YAAY,GAAG;AACb,UAAME,OAAO,GAAI,kDACf,KAAKrB,UACN,gBAAe,KAAKO,MAAL,CAAYQ,OAAZ,EAAsB,wBAAuB,KAAKhB,IAAK,IAFvE;AAIA,UAAM,IAAIuB,mBAAJ,CAAeD,OAAf,EAAwB,KAAKd,MAAL,CAAYgB,QAAZ,EAAxB,EAAgD,IAAhD,CAAN;AACD;;AAEDL,EAAAA,eAAe,GAAG;AAChB,QAAI,KAAKX,MAAL,CAAYiB,OAAZ,EAAJ,EAA2B;AACzB,WAAKjB,MAAL,CAAYkB,IAAZ;AACD;AACF;;AAEDC,EAAAA,KAAK,GAAG;AACN,WAAO,IAAI9B,UAAJ,CAAe,KAAKG,IAApB,EAA0B,KAAKC,UAA/B,CAAP;AACD;;AAED2B,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAK3B,UAAZ;AACD;;AA7FkD","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ParseError from \"../ParseError.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport Cursor from \"../../Cursor.js\";\n\nexport default class AnyOfThese extends ValuePattern {\n  constructor(name, characters) {\n    super();\n    this.name = name;\n    this.characters = characters;\n\n    this.reset();\n    this.assertArguments();\n  }\n\n  assertArguments() {\n    if (typeof this.name !== \"string\") {\n      throw new Error(\"Invalid Arguments: The name needs to be a string.\");\n    }\n\n    if (typeof this.characters !== \"string\") {\n      throw new Error(\n        \"Invalid Arguments: The characters argument needs to be a string of characters.\"\n      );\n    }\n\n    if (this.characters.length < 1) {\n      throw new Error(\n        \"Invalid Arguments: The characters argument needs to be at least one character long.\"\n      );\n    }\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.assertCursor();\n    this.tryParse();\n    return this.node;\n  }\n\n  assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  reset(cursor) {\n    if (cursor == null) {\n      this.cursor = null;\n      this.mark = null;\n    } else {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n\n    this.node = null;\n  }\n\n  tryParse() {\n    if (this.isMatch()) {\n      const value = this.cursor.getChar();\n      const index = this.mark.index;\n\n      this.node = new ValueNode(this.name, value, index, index);\n      this.incrementCursor();\n    } else {\n      this.processError();\n    }\n  }\n\n  isMatch() {\n    return this.characters.indexOf(this.cursor.getChar()) > -1;\n  }\n\n  processError() {\n    const message = `ParseError: Expected one of these characters, '${\n      this.characters\n    }' but found '${this.cursor.getChar()}' while parsing for '${this.name}'.`;\n\n    throw new ParseError(message, this.cursor.getIndex(), this);\n  }\n\n  incrementCursor() {\n    if (this.cursor.hasNext()) {\n      this.cursor.next();\n    }\n  }\n\n  clone() {\n    return new AnyOfThese(this.name, this.characters);\n  }\n\n  getValue() {\n    return this.characters;\n  }\n}\n"],"file":"AnyOfThese.js"}