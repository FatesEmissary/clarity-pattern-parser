{"version":3,"sources":["../../../src/patterns/value/AndValue.js"],"names":["AndValue","name","patterns","_assertArguments","_children","length","Error","cursor","index","nodes","node","mark","_reset","_assertCursor","_tryPattern","Cursor","pattern","push","parse","error","stack","StackInformation","lastNode","setIndex","endIndex","_processValue","startIndex","value","filter","map","join","ValueNode","ValuePattern"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,Q;;;;;AACnB,oBAAYC,IAAZ,EAAkBC,QAAlB,EAA4B;AAAA;;AAAA;;AAC1B,kFAAMD,IAAN,EAAYC,QAAZ;;AACA,UAAKC,gBAAL;;AAF0B;AAG3B;;;;uCAEkB;AACjB,UAAI,KAAKC,SAAL,CAAeC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,cAAM,IAAIC,KAAJ,CACJ,uEADI,CAAN;AAGD;AACF;;;2BAEMC,M,EAAQ;AACb,WAAKA,MAAL,GAAc,IAAd;AACA,WAAKC,KAAL,GAAa,CAAb;AACA,WAAKC,KAAL,GAAa,EAAb;AACA,WAAKC,IAAL,GAAY,IAAZ;;AAEA,UAAIH,MAAM,IAAI,IAAd,EAAoB;AAClB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKI,IAAL,GAAY,KAAKJ,MAAL,CAAYI,IAAZ,EAAZ;AACD;AACF;;;0BAEKJ,M,EAAQ;AACZ,WAAKK,MAAL,CAAYL,MAAZ;;AACA,WAAKM,aAAL;;AACA,WAAKC,WAAL;;AAEA,aAAO,KAAKJ,IAAZ;AACD;;;oCAEe;AACd,UAAI,EAAE,KAAKH,MAAL,YAAuBQ,eAAzB,CAAJ,EAAsC;AACpC,cAAM,IAAIT,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;;kCAEa;AACZ,aAAO,IAAP,EAAa;AACX,YAAMU,OAAO,GAAG,KAAKZ,SAAL,CAAe,KAAKI,KAApB,CAAhB;;AAEA,YAAI;AACF,eAAKC,KAAL,CAAWQ,IAAX,CAAgBD,OAAO,CAACE,KAAR,CAAc,KAAKX,MAAnB,CAAhB;AACD,SAFD,CAEE,OAAOY,KAAP,EAAc;AACdA,UAAAA,KAAK,CAACC,KAAN,CAAYH,IAAZ,CAAiB,IAAII,yBAAJ,CAAqB,KAAKV,IAA1B,EAAgC,IAAhC,CAAjB;AACA,gBAAMQ,KAAN;AACD;;AAED,YAAI,KAAKX,KAAL,GAAa,CAAb,GAAiB,KAAKJ,SAAL,CAAeC,MAApC,EAA4C;AAC1C,cAAMiB,QAAQ,GAAG,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWJ,MAAX,GAAoB,CAA/B,CAAjB;AAEA,eAAKE,MAAL,CAAYgB,QAAZ,CAAqBD,QAAQ,CAACE,QAAT,GAAoB,CAAzC;AACA,eAAKhB,KAAL;AACD,SALD,MAKO;AACL,eAAKiB,aAAL;;AACA;AACD;AACF;AACF;;;oCAEe;AACd,UAAMH,QAAQ,GAAG,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWJ,MAAX,GAAoB,CAA/B,CAAjB;AACA,UAAMqB,UAAU,GAAG,KAAKf,IAAL,CAAUH,KAA7B;AACA,UAAMgB,QAAQ,GAAGF,QAAQ,CAACE,QAA1B;AAEA,UAAMG,KAAK,GAAG,KAAKlB,KAAL,CACXmB,MADW,CACJ,UAAAlB,IAAI;AAAA,eAAIA,IAAI,IAAI,IAAZ;AAAA,OADA,EAEXmB,GAFW,CAEP,UAAAnB,IAAI;AAAA,eAAIA,IAAI,CAACiB,KAAT;AAAA,OAFG,EAGXG,IAHW,CAGN,EAHM,CAAd;AAKA,WAAKpB,IAAL,GAAY,IAAIqB,kBAAJ,CAAc,KAAK9B,IAAnB,EAAyB0B,KAAzB,EAAgCD,UAAhC,EAA4CF,QAA5C,CAAZ;AACD;;;4BAEO;AACN,aAAO,IAAIxB,QAAJ,CAAa,KAAKC,IAAlB,EAAwB,KAAKG,SAA7B,CAAP;AACD;;;;EA9EmC4B,sB","sourcesContent":["import ValuePattern from \"./ValuePattern\";\nimport ValueNode from \"../../ast/ValueNode\";\nimport Cursor from \"../../Cursor.js\";\nimport StackInformation from \"../StackInformation\";\n\nexport default class AndValue extends ValuePattern {\n  constructor(name, patterns) {\n    super(name, patterns);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._children.length < 2) {\n      throw new Error(\n        \"Invalid Argument: AndValue needs to have more than one value pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor) {\n    this.cursor = null;\n    this.index = 0;\n    this.nodes = [];\n    this.node = null;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._assertCursor();\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  _tryPattern() {\n    while (true) {\n      const pattern = this._children[this.index];\n\n      try {\n        this.nodes.push(pattern.parse(this.cursor));\n      } catch (error) {\n        error.stack.push(new StackInformation(this.mark, this));\n        throw error;\n      }\n\n      if (this.index + 1 < this._children.length) {\n        const lastNode = this.nodes[this.nodes.length - 1];\n\n        this.cursor.setIndex(lastNode.endIndex + 1);\n        this.index++;\n      } else {\n        this._processValue();\n        break;\n      }\n    }\n  }\n\n  _processValue() {\n    const lastNode = this.nodes[this.nodes.length - 1];\n    const startIndex = this.mark.index;\n    const endIndex = lastNode.endIndex;\n\n    const value = this.nodes\n      .filter(node => node != null)\n      .map(node => node.value)\n      .join(\"\");\n\n    this.node = new ValueNode(this.name, value, startIndex, endIndex);\n  }\n\n  clone() {\n    return new AndValue(this.name, this._children);\n  }\n}\n"],"file":"AndValue.js"}