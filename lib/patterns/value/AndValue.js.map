{"version":3,"sources":["../../../src/patterns/value/AndValue.js"],"names":["permutor","Permutor","AndValue","name","patterns","_assertArguments","_children","length","Error","cursor","index","nodes","node","mark","_reset","_tryPatterns","pattern","parse","hasUnresolvedError","push","_next","_processValue","_hasMorePatterns","hasNext","next","_assertRestOfPatternsAreOptional","areTheRestOptional","children","every","OptionalValue","parseError","ParseError","throwError","filter","lastNode","startIndex","endIndex","value","map","join","ValueNode","addMatch","rootPattern","Pattern","possibilities","child","getPossibilities","permute","tokens","x","concat","getTokens","ValuePattern"],"mappings":"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","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ParseError from \"../../patterns/ParseError.js\";\nimport OptionalValue from \"./OptionalValue.js\";\nimport Permutor from \"../../Permutor.js\";\nimport Pattern from \"../Pattern.js\";\n\nconst permutor = new Permutor();\n\nexport default class AndValue extends ValuePattern {\n  constructor(name, patterns) {\n    super(\"and-value\", name, patterns);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._children.length < 2) {\n      throw new Error(\n        \"Invalid Argument: AndValue needs to have more than one value pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor) {\n    this.index = 0;\n    this.nodes = [];\n    this.node = null;\n    this.cursor = cursor;\n    this.mark = this.cursor.mark();\n  }\n\n  parse(cursor) {\n    this._reset(cursor);\n    this._tryPatterns();\n\n    return this.node;\n  }\n\n  _tryPatterns() {\n    while (true) {\n      const pattern = this._children[this.index];\n      const node = pattern.parse(this.cursor);\n\n      if (this.cursor.hasUnresolvedError()) {\n        break;\n      } else {\n        this.nodes.push(node);\n      }\n\n      if (!this._next()) {\n        this._processValue();\n        break;\n      }\n    }\n  }\n\n  _next() {\n    if (this._hasMorePatterns()) {\n      if (this.cursor.hasNext()) {\n        // If the last result was a failed optional, then don't increment the cursor.\n        if (this.nodes[this.nodes.length - 1] != null) {\n          this.cursor.next();\n        }\n\n        this.index++;\n        return true;\n      } else if (this.nodes[this.nodes.length - 1] == null) {\n        this.index++;\n        return true;\n      }\n\n      this._assertRestOfPatternsAreOptional();\n      return false;\n    } else {\n      return false;\n    }\n  }\n\n  _hasMorePatterns() {\n    return this.index + 1 < this._children.length;\n  }\n\n  _assertRestOfPatternsAreOptional() {\n    const areTheRestOptional = this.children.every((pattern, index) => {\n      return index <= this.index || pattern instanceof OptionalValue;\n    });\n\n    if (!areTheRestOptional) {\n      const parseError = new ParseError(\n        `Could not match ${this.name} before string ran out.`,\n        this.index,\n        this\n      );\n\n      this.cursor.throwError(parseError);\n    }\n  }\n\n  _processValue() {\n    if (this.cursor.hasUnresolvedError()) {\n      this.node = null;\n    } else {\n      this.nodes = this.nodes.filter((node) => node != null);\n\n      const lastNode = this.nodes[this.nodes.length - 1];\n      const startIndex = this.mark;\n      const endIndex = lastNode.endIndex;\n      const value = this.nodes.map((node) => node.value).join(\"\");\n\n      this.node = new ValueNode(\n        \"and-value\",\n        this.name,\n        value,\n        startIndex,\n        endIndex\n      );\n\n      this.cursor.index = this.node.endIndex;\n      this.cursor.addMatch(this, this.node);\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new AndValue(name, this._children);\n  }\n\n  getPossibilities(rootPattern) {\n    if (rootPattern == null || !(rootPattern instanceof Pattern)) {\n      rootPattern = this;\n    }\n\n    const possibilities = this.children.map((child) =>\n      child.getPossibilities(rootPattern)\n    );\n    return permutor.permute(possibilities);\n  }\n\n  getTokens() {\n    let tokens = [];\n\n    for (let x = 0; x < this._children.length; x++) {\n      const child = this._children[x];\n\n      if (child instanceof OptionalValue) {\n        tokens = tokens.concat(child.getTokens());\n      } else {\n        tokens = tokens.concat(child.getTokens());\n        break;\n      }\n    }\n\n    return tokens;\n  }\n}\n"],"file":"AndValue.js"}