{"version":3,"sources":["../../../src/patterns/value/AndValue.js"],"names":["AndValue","name","patterns","_assertArguments","_children","length","Error","cursor","parseError","index","nodes","node","mark","ParseError","_reset","_assertCursor","_tryPatterns","Cursor","pattern","push","parse","error","stack","StackInformation","_next","_processValue","_hasMorePatterns","hasNext","next","_assertRestOfPatternsAreOptional","areTheRestOptional","children","every","OptionalValue","message","filter","lastNode","startIndex","endIndex","value","map","join","ValueNode","setIndex","ValuePattern"],"mappings":"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","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport Cursor from \"../../Cursor.js\";\nimport ParseError from \"../../patterns/ParseError.js\";\nimport StackInformation from \"../StackInformation.js\";\nimport OptionalValue from \"./OptionalValue.js\";\n\nexport default class AndValue extends ValuePattern {\n  constructor(name, patterns) {\n    super(name, patterns);\n    this._assertArguments();\n  }\n\n  _assertArguments() {\n    if (this._children.length < 2) {\n      throw new Error(\n        \"Invalid Argument: AndValue needs to have more than one value pattern.\"\n      );\n    }\n  }\n\n  _reset(cursor, parseError) {\n    this.cursor = null;\n    this.index = 0;\n    this.nodes = [];\n    this.node = null;\n    this.parseError = parseError;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n\n    if (parseError == null) {\n      this.parseError = new ParseError();\n    }\n  }\n\n  parse(cursor, parseError) {\n    this._reset(cursor, parseError);\n    this._assertCursor();\n    this._tryPatterns();\n\n    return this.node;\n  }\n\n  _assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  _tryPatterns() {\n    while (true) {\n      const pattern = this._children[this.index];\n\n      try {\n        this.nodes.push(pattern.parse(this.cursor, this.parseError));\n      } catch (error) {\n        error.stack.push(new StackInformation(this.mark, this));\n        throw error;\n      }\n\n      if (!this._next()) {\n        this._processValue();\n        break;\n      }\n    }\n  }\n\n  _next() {\n    if (this._hasMorePatterns()) {\n      if (this.cursor.hasNext()) {\n        // If the last result was a failed optional, then don't increment the cursor.\n        if (this.nodes[this.nodes.length - 1] != null) {\n          this.cursor.next();\n        }\n\n        this.index++;\n        return true;\n      } else if (this.nodes[this.nodes.length - 1] == null) {\n        this.index++;\n        return true;\n      }\n\n      this._assertRestOfPatternsAreOptional();\n      return false;\n    } else {\n      return false;\n    }\n  }\n\n  _hasMorePatterns() {\n    return this.index + 1 < this._children.length;\n  }\n\n  _assertRestOfPatternsAreOptional() {\n    const areTheRestOptional = this.children.every((pattern, index) => {\n      return index <= this.index || pattern instanceof OptionalValue;\n    });\n\n    if (!areTheRestOptional) {\n      this.parseError.message = `Could not match ${this.name} before string ran out.`;\n      this.parseError.index = this.index;\n      this.parseError.pattern = this;\n\n      throw this.parseError;\n    }\n  }\n\n  _processValue() {\n    this.nodes = this.nodes.filter(node => node != null);\n\n    const lastNode = this.nodes[this.nodes.length - 1];\n    const startIndex = this.mark.index;\n    const endIndex = lastNode.endIndex;\n    const value = this.nodes.map(node => node.value).join(\"\");\n\n    this.node = new ValueNode(this.name, value, startIndex, endIndex);\n\n    this.cursor.setIndex(this.node.endIndex);\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new AndValue(name, this._children);\n  }\n\n  getCurrentMark() {\n    return this.mark;\n  }\n}\n"],"file":"AndValue.js"}