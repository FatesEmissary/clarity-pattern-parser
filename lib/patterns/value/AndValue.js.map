{"version":3,"sources":["../../../src/patterns/value/AndValue.js"],"names":["AndValue","ValuePatterns","constructor","name","patterns","reset","cursor","index","nodes","node","mark","parse","assertCursor","tryPattern","Cursor","Error","pattern","push","error","patternStack","length","lastNode","setIndex","endIndex","processValue","startIndex","value","filter","map","join","ValueNode","clone"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEe,MAAMA,QAAN,SAAuBC,sBAAvB,CAAqC;AAClDC,EAAAA,WAAW,CAACC,IAAD,EAAOC,QAAP,EAAiB;AAC1B,UAAMD,IAAN,EAAYC,QAAZ;AACA,SAAKC,KAAL;AACD;;AAEDA,EAAAA,KAAK,CAACC,MAAD,EAAS;AACZ,SAAKA,MAAL,GAAc,IAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,KAAL,GAAa,EAAb;AACA,SAAKC,IAAL,GAAY,IAAZ;;AAEA,QAAIH,MAAM,IAAI,IAAd,EAAoB;AAClB,WAAKA,MAAL,GAAcA,MAAd;AACA,WAAKI,IAAL,GAAY,KAAKJ,MAAL,CAAYI,IAAZ,EAAZ;AACD;AACF;;AAEDC,EAAAA,KAAK,CAACL,MAAD,EAAS;AACZ,SAAKD,KAAL,CAAWC,MAAX;AACA,SAAKM,YAAL;AACA,SAAKC,UAAL;AAEA,WAAO,KAAKJ,IAAZ;AACD;;AAEDG,EAAAA,YAAY,GAAG;AACb,QAAI,EAAE,KAAKN,MAAL,YAAuBQ,eAAzB,CAAJ,EAAsC;AACpC,YAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;AAEDF,EAAAA,UAAU,GAAG;AACX,WAAO,IAAP,EAAa;AACX,YAAMG,OAAO,GAAG,KAAKZ,QAAL,CAAc,KAAKG,KAAnB,CAAhB;;AAEA,UAAI;AACF,aAAKC,KAAL,CAAWS,IAAX,CAAgBD,OAAO,CAACL,KAAR,CAAc,KAAKL,MAAnB,CAAhB;AACD,OAFD,CAEE,OAAOY,KAAP,EAAc;AACdA,QAAAA,KAAK,CAACC,YAAN,CAAmBF,IAAnB,CAAwB,IAAxB;AACA,cAAMC,KAAN;AACD;;AAED,UAAI,KAAKX,KAAL,GAAa,CAAb,GAAiB,KAAKH,QAAL,CAAcgB,MAAnC,EAA2C;AACzC,cAAMC,QAAQ,GAAG,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWY,MAAX,GAAoB,CAA/B,CAAjB;AAEA,aAAKd,MAAL,CAAYgB,QAAZ,CAAqBD,QAAQ,CAACE,QAAT,GAAoB,CAAzC;AACA,aAAKhB,KAAL;AACD,OALD,MAKO;AACL,aAAKiB,YAAL;AACA;AACD;AACF;AACF;;AAEDA,EAAAA,YAAY,GAAG;AACb,UAAMH,QAAQ,GAAG,KAAKb,KAAL,CAAW,KAAKA,KAAL,CAAWY,MAAX,GAAoB,CAA/B,CAAjB;AACA,UAAMK,UAAU,GAAG,KAAKf,IAAL,CAAUH,KAA7B;AACA,UAAMgB,QAAQ,GAAGF,QAAQ,CAACE,QAA1B;AAEA,UAAMG,KAAK,GAAG,KAAKlB,KAAL,CACXmB,MADW,CACJlB,IAAI,IAAIA,IAAI,IAAI,IADZ,EAEXmB,GAFW,CAEPnB,IAAI,IAAIA,IAAI,CAACiB,KAFN,EAGXG,IAHW,CAGN,EAHM,CAAd;AAKA,SAAKpB,IAAL,GAAY,IAAIqB,kBAAJ,CAAc,KAAK3B,IAAnB,EAAyBuB,KAAzB,EAAgCD,UAAhC,EAA4CF,QAA5C,CAAZ;AACD;;AAEDQ,EAAAA,KAAK,GAAG;AACN,WAAO,IAAI/B,QAAJ,CAAa,KAAKG,IAAlB,EAAwB,KAAKC,QAA7B,CAAP;AACD;;AAtEiD","sourcesContent":["import ValuePatterns from \"./ValuePatterns\";\nimport ValueNode from \"../../ast/ValueNode\";\nimport Cursor from \"../../Cursor.js\";\n\nexport default class AndValue extends ValuePatterns {\n  constructor(name, patterns) {\n    super(name, patterns);\n    this.reset();\n  }\n\n  reset(cursor) {\n    this.cursor = null;\n    this.index = 0;\n    this.nodes = [];\n    this.node = null;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.assertCursor();\n    this.tryPattern();\n\n    return this.node;\n  }\n\n  assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new Error(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  tryPattern() {\n    while (true) {\n      const pattern = this.patterns[this.index];\n\n      try {\n        this.nodes.push(pattern.parse(this.cursor));\n      } catch (error) {\n        error.patternStack.push(this);\n        throw error;\n      }\n\n      if (this.index + 1 < this.patterns.length) {\n        const lastNode = this.nodes[this.nodes.length - 1];\n\n        this.cursor.setIndex(lastNode.endIndex + 1);\n        this.index++;\n      } else {\n        this.processValue();\n        break;\n      }\n    }\n  }\n\n  processValue() {\n    const lastNode = this.nodes[this.nodes.length - 1];\n    const startIndex = this.mark.index;\n    const endIndex = lastNode.endIndex;\n\n    const value = this.nodes\n      .filter(node => node != null)\n      .map(node => node.value)\n      .join(\"\");\n\n    this.node = new ValueNode(this.name, value, startIndex, endIndex);\n  }\n\n  clone() {\n    return new AndValue(this.name, this.patterns);\n  }\n}\n"],"file":"AndValue.js"}