{"version":3,"sources":["../../../src/patterns/value/NotValue.js"],"names":["NotValue","name","pattern","_assertArguments","_reset","children","ValuePattern","Error","cursor","parseError","mark","match","node","ParseError","_tryPattern","parse","moveToMark","error","getChar","_processMatch","length","parserError","message","index","ValueNode","setIndex","endIndex"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;IAEqBA,Q;;;;;AACnB,oBAAYC,IAAZ,EAAkBC,OAAlB,EAA2B;AAAA;;AAAA;;AACzB,kFAAMD,IAAN,EAAY,CAACC,OAAD,CAAZ;;AACA,UAAKC,gBAAL;;AACA,UAAKC,MAAL;;AAHyB;AAI1B;;;;uCAEkB;AACjB,UAAI,EAAE,KAAKC,QAAL,CAAc,CAAd,aAA4BC,sBAA9B,CAAJ,EAAiD;AAC/C,cAAM,IAAIC,KAAJ,CACJ,+DADI,CAAN;AAGD;;AAED,UAAI,OAAO,KAAKN,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,cAAM,IAAIM,KAAJ,CAAU,kDAAV,CAAN;AACD;AACF;;;2BAEMC,M,EAAQC,U,EAAY;AACzB,WAAKD,MAAL,GAAc,IAAd;AACA,WAAKE,IAAL,GAAY,IAAZ;AACA,WAAKC,KAAL,GAAa,EAAb;AACA,WAAKC,IAAL,GAAY,IAAZ;AACA,WAAKH,UAAL,GAAkBA,UAAlB;;AAEA,UAAID,MAAM,IAAI,IAAd,EAAoB;AAClB,aAAKA,MAAL,GAAcA,MAAd;AACA,aAAKE,IAAL,GAAY,KAAKF,MAAL,CAAYE,IAAZ,EAAZ;AACD;;AAED,UAAID,UAAU,IAAI,IAAlB,EAAwB;AACtB,aAAKA,UAAL,GAAkB,IAAII,mBAAJ,EAAlB;AACD;AACF;;;0BAEKL,M,EAAQC,U,EAAY;AACxB,WAAKL,MAAL,CAAYI,MAAZ,EAAoBC,UAApB;;AACA,WAAKK,WAAL;;AAEA,aAAO,KAAKF,IAAZ;AACD;;;kCAEa;AACZ,aAAO,IAAP,EAAa;AACX,YAAMF,IAAI,GAAG,KAAKF,MAAL,CAAYE,IAAZ,EAAb;;AAEA,YAAI;AACF,eAAKL,QAAL,CAAc,CAAd,EAAiBU,KAAjB,CAAuB,KAAKP,MAA5B,EAAoC,KAAKC,UAAzC;AACA,eAAKD,MAAL,CAAYQ,UAAZ,CAAuBN,IAAvB;AACA;AACD,SAJD,CAIE,OAAOO,KAAP,EAAc;AACd,eAAKT,MAAL,CAAYQ,UAAZ,CAAuBN,IAAvB;AACA,eAAKC,KAAL,IAAc,KAAKH,MAAL,CAAYU,OAAZ,EAAd;AACA;AACD;AACF;;AAED,WAAKC,aAAL;AACD;;;oCAEe;AACd,UAAI,KAAKR,KAAL,CAAWS,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,aAAKC,WAAL,CAAiBC,OAAjB,6DAA8E,KAAKjB,QAAL,CAAc,CAAd,EAAiBJ,IAA/F;AACA,aAAKQ,UAAL,CAAgBc,KAAhB,GAAwB,KAAKb,IAAL,CAAUa,KAAlC;AACA,aAAKF,WAAL,CAAiBnB,OAAjB,GAA2B,IAA3B;AAEA,cAAM,KAAKO,UAAX;AACD,OAND,MAMO;AACL,aAAKG,IAAL,GAAY,IAAIY,kBAAJ,CACV,KAAKvB,IADK,EAEV,KAAKU,KAFK,EAGV,KAAKD,IAAL,CAAUa,KAHA,EAIV,KAAKb,IAAL,CAAUa,KAJA,CAAZ;AAOA,aAAKf,MAAL,CAAYiB,QAAZ,CAAqB,KAAKb,IAAL,CAAUc,QAA/B;AACD;AACF;;;0BAEKzB,I,EAAM;AACV,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,QAAAA,IAAI,GAAG,KAAKA,IAAZ;AACD;;AACD,aAAO,IAAID,QAAJ,CAAaC,IAAb,EAAmB,KAAKI,QAAL,CAAc,CAAd,CAAnB,CAAP;AACD;;;qCAEgB;AACf,aAAO,KAAKK,IAAZ;AACD;;;;EAzFmCJ,sB","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../../ast/ValueNode.js\";\nimport ParseError from \"../ParseError.js\";\n\nexport default class NotValue extends ValuePattern {\n  constructor(name, pattern) {\n    super(name, [pattern]);\n    this._assertArguments();\n    this._reset();\n  }\n\n  _assertArguments() {\n    if (!(this.children[0] instanceof ValuePattern)) {\n      throw new Error(\n        \"Invalid Arguments: Expected the pattern to be a ValuePattern.\"\n      );\n    }\n\n    if (typeof this.name !== \"string\") {\n      throw new Error(\"Invalid Arguments: Expected name to be a string.\");\n    }\n  }\n\n  _reset(cursor, parseError) {\n    this.cursor = null;\n    this.mark = null;\n    this.match = \"\";\n    this.node = null;\n    this.parseError = parseError;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = this.cursor.mark();\n    }\n\n    if (parseError == null) {\n      this.parseError = new ParseError();\n    }\n  }\n\n  parse(cursor, parseError) {\n    this._reset(cursor, parseError);\n    this._tryPattern();\n\n    return this.node;\n  }\n\n  _tryPattern() {\n    while (true) {\n      const mark = this.cursor.mark();\n\n      try {\n        this.children[0].parse(this.cursor, this.parseError);\n        this.cursor.moveToMark(mark);\n        break;\n      } catch (error) {\n        this.cursor.moveToMark(mark);\n        this.match += this.cursor.getChar();\n        break;\n      }\n    }\n\n    this._processMatch();\n  }\n\n  _processMatch() {\n    if (this.match.length === 0) {\n      this.parserError.message = `Didn't find any characters the didn't match the ${this.children[0].name} pattern.`;\n      this.parseError.index = this.mark.index;\n      this.parserError.pattern = this;\n\n      throw this.parseError;\n    } else {\n      this.node = new ValueNode(\n        this.name,\n        this.match,\n        this.mark.index,\n        this.mark.index\n      );\n\n      this.cursor.setIndex(this.node.endIndex);\n    }\n  }\n\n  clone(name) {\n    if (typeof name !== \"string\") {\n      name = this.name;\n    }\n    return new NotValue(name, this.children[0]);\n  }\n\n  getCurrentMark() {\n    return this.mark;\n  }\n}\n"],"file":"NotValue.js"}