{"version":3,"sources":["../../src/patterns/OrValue.js"],"names":["OrValue","ValuePattern","constructor","name","patterns","assertArguments","reset","clonePatterns","Array","isArray","Error","areAllPatterns","every","pattern","length","cursor","mark","index","errors","node","map","clone","parse","assertCursor","tryPattern","ValueNode","value","Cursor","ParseError","error","processError","push","moveToMark","throwError","reduce","furthestError","nextError","getName","getValue","getPatterns"],"mappings":"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","sourcesContent":["import ValuePattern from \"./ValuePattern.js\";\nimport ValueNode from \"../ast/ValueNode.js\";\nimport Cursor from \"../Cursor.js\";\n\nexport default class OrValue extends ValuePattern {\n  constructor(name, patterns) {\n    super();\n    this.name = name;\n    this.patterns = patterns;\n    this.assertArguments();\n    this.reset();\n    this.clonePatterns();\n  }\n\n  assertArguments() {\n    if (!Array.isArray(this.patterns)) {\n      throw new Error(\n        \"Invalid Arguments: The patterns argument need to be an array of ValuePatterns.\"\n      );\n    }\n\n    const areAllPatterns = this.patterns.every(\n      pattern => pattern instanceof ValuePattern\n    );\n\n    if (!areAllPatterns) {\n      throw new Error(\n        \"Invalid Argument: All patterns need to be an instance of ValuePattern.\"\n      );\n    }\n\n    if (this.patterns.length < 2) {\n      throw new Error(\n        \"Invalid Argument: OrValue needs to have more than one value pattern.\"\n      );\n    }\n\n    if (typeof this.name !== \"string\") {\n      throw new Error(\n        \"Invalid Argument: OrValue needs to have a name that's a string.\"\n      );\n    }\n  }\n\n  reset(cursor) {\n    this.cursor = null;\n    this.mark = null;\n    this.index = 0;\n    this.errors = [];\n    this.node = null;\n\n    if (cursor != null) {\n      this.cursor = cursor;\n      this.mark = cursor.mark();\n    }\n  }\n\n  clonePatterns() {\n    // We need to clone the patterns so nested patterns can be parsed.\n    this.patterns = this.patterns.map(pattern => pattern.clone());\n  }\n\n  parse(cursor) {\n    this.reset(cursor);\n    this.assertCursor();\n    this.tryPattern();\n\n    return new ValueNode(this.name, this.node.value);\n  }\n\n  assertCursor() {\n    if (!(this.cursor instanceof Cursor)) {\n      throw new ParseError(\"Invalid Arguments: Expected a cursor.\");\n    }\n  }\n\n  tryPattern() {\n    const pattern = this.patterns[this.index];\n\n    try {\n      this.node = pattern.parse(this.cursor);\n    } catch (error) {\n      this.processError(error);\n    }\n  }\n\n  processError(error) {\n    this.errors.push(error);\n\n    if (this.index + 1 < this.patterns.length) {\n      this.index++;\n      this.cursor.moveToMark(this.mark);\n      this.tryPattern();\n    } else {\n      this.throwError();\n    }\n  }\n\n  throwError() {\n    const error = this.errors.reduce((furthestError, nextError) => {\n      if (furthestError.index > nextError.index) {\n        return furthestError;\n      } else {\n        return nextError;\n      }\n    });\n\n    throw error;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getValue() {\n    return null;\n  }\n\n  getPatterns() {\n    return this.patterns;\n  }\n\n  clone() {\n    return new OrValue(this.name, this.patterns);\n  }\n}\n"],"file":"OrValue.js"}